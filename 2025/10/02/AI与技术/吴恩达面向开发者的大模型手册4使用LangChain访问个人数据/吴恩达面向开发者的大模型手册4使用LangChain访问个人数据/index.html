

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/images/avatar.jpg">
  <link rel="icon" href="/images/avatar.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peng Yue">
  <meta name="keywords" content="Axure/Figma、Xmind、SQL、Python/Java、Git、Visio、Tableau、Cursor、Gemini、Prompt Engineering、Dify、Coze、agent">
  
    <meta name="description" content="第四部分 使用LangChain访问个人数据目录：简介 Introduction加载文档 Document Loading文档切割 Document Splitting向量数据库与词向量 Vectorstores and Embeddings检索 Retrieval问答 Question Answering聊天 Chat总结 Summary 第一章 简介 Introduction背景：大语言模型的">
<meta property="og:type" content="article">
<meta property="og:title" content="吴恩达面向开发者的大模型手册4使用LangChain访问个人数据">
<meta property="og:url" content="https://py0909.github.io/2025/10/02/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C4%E4%BD%BF%E7%94%A8LangChain%E8%AE%BF%E9%97%AE%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C4%E4%BD%BF%E7%94%A8LangChain%E8%AE%BF%E9%97%AE%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE/index.html">
<meta property="og:site_name" content="Peng Yue的产品思考博客">
<meta property="og:description" content="第四部分 使用LangChain访问个人数据目录：简介 Introduction加载文档 Document Loading文档切割 Document Splitting向量数据库与词向量 Vectorstores and Embeddings检索 Retrieval问答 Question Answering聊天 Chat总结 Summary 第一章 简介 Introduction背景：大语言模型的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://py0909.github.io/llmcookbook.jpg">
<meta property="article:published_time" content="2025-10-01T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-23T15:20:55.130Z">
<meta property="article:author" content="Peng Yue">
<meta property="article:tag" content="Prompt">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://py0909.github.io/llmcookbook.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>吴恩达面向开发者的大模型手册4使用LangChain访问个人数据 - Peng Yue的产品思考博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"py0909.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Peng Yue的产品笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/" target="_self">
                <i class="iconfont icon-ppt"></i>
                <span>项目复盘</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>AI探索</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E4%BA%A7%E5%93%81%E6%8B%86%E8%A7%A3/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>产品拆解</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/" target="_self">
                <i class="iconfont icon-book-fill"></i>
                <span>方法论</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/" target="_self">
                <i class="iconfont icon-pen"></i>
                <span>原型设计</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/llmcookbook.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="吴恩达面向开发者的大模型手册4使用LangChain访问个人数据"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Peng Yue
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-02 00:00" pubdate>
          2025年10月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          68k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          568 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">吴恩达面向开发者的大模型手册4使用LangChain访问个人数据</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第四部分-使用LangChain访问个人数据"><a href="#第四部分-使用LangChain访问个人数据" class="headerlink" title="第四部分 使用LangChain访问个人数据"></a>第四部分 使用LangChain访问个人数据</h1><p>目录：<br>简介 Introduction<br>加载文档 Document Loading<br>文档切割 Document Splitting<br>向量数据库与词向量 Vectorstores and Embeddings<br>检索 Retrieval<br>问答 Question Answering<br>聊天 Chat<br>总结 Summary</p>
<h2 id="第一章-简介-Introduction"><a href="#第一章-简介-Introduction" class="headerlink" title="第一章 简介 Introduction"></a>第一章 简介 Introduction</h2><p>背景：大语言模型的知识来源于其训练数据集，并没有用户的信息（比如用户的个人数据，公司的自有数据），也没有最新发生时事的信息（在大模型数据训练后发表的文章或者新闻）。因此大模型能给出的答案比较受限。<br>LangChain的组件包括：<br>提示(Prompts)：使模型执行操作的方式。<br>模型(Models)：大语言模型、对话模型，文本表示模型。目前包含多个模型的集成。<br>索引(Indexes)：获取数据的方式，可以与模型结合使用。<br>链(Chains)：端到端功能实现。<br>代理(Agents)：使用模型作为推理引擎</p>
<p>主要步骤：</p>
<ol>
<li>加载文档（文档加载器加载不同的数据源）</li>
<li>文档切割（切割为具有语意的段落）——不同的切割可能产生很大的影响</li>
<li>向量数据库与词向量</li>
<li>语义搜索与信息检索</li>
<li>问答</li>
<li>聊天</li>
<li>总结</li>
</ol>
<h2 id="第二章-文档加载-Document-Loading"><a href="#第二章-文档加载-Document-Loading" class="headerlink" title="第二章 文档加载 Document Loading"></a>第二章 文档加载 Document Loading</h2><p>多模态数据：PDF 文档、视频、网页等<br>一、PDF文档<br>二、YouTube音频<br>三、网页文档<br>四、Notion文档</p>
<p>我们使用<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/fantastic-matplotlib/%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%A3%E4%BD%9C%E4%B8%BA%E7%A4%BA%E4%BE%8B">https://datawhalechina.github.io/fantastic-matplotlib/这个文档作为示例</a><br>需要安装第三方库 pypdf<br>!pip install -q pypdf</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==== 01 加载pdf文档 ====&quot;</span>)<br><span class="hljs-comment"># 1. 导入 PyPDFLoader</span><br><span class="hljs-comment"># v0.3 变化：必须从 langchain_community 导入</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> PyPDFLoader<br><br><span class="hljs-comment"># 2. 创建加载器实例</span><br><span class="hljs-comment"># 语法：类名(参数) -&gt; 实例化对象</span><br><span class="hljs-comment"># 含义：创建一个专门用于处理 PDF 的工具对象，并告诉它文件在哪</span><br>loader = PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第一回：Matplotlib初相识.pdf&quot;</span>)<br><br><span class="hljs-comment"># 3. 执行加载</span><br><span class="hljs-comment"># 语法：对象.方法名()</span><br><span class="hljs-comment"># 含义：读取 PDF 文件，按页拆分，并把每一页转换成 LangChain 的 Document 对象</span><br>pages = loader.load()<br><br><span class="hljs-comment"># 4. 探索数据</span><br><span class="hljs-comment"># pages 是一个列表 (List)，列表里装的是 Document 对象</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(pages)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;总页数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(pages)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 5. 查看单页内容</span><br><span class="hljs-comment"># 语法：列表[索引] -&gt; 取出第一个元素</span><br>page = pages[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;单页类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(page)&#125;</span>&quot;</span>) <span class="hljs-comment"># 类型为 langchain_core.documents.base.Document</span><br><br><span class="hljs-comment"># 6. 查看 Document 对象的属性</span><br><span class="hljs-comment"># .page_content: 存放提取出来的纯文本</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;前500个字符: <span class="hljs-subst">&#123;page.page_content[<span class="hljs-number">0</span>:<span class="hljs-number">500</span>]&#125;</span>&quot;</span>)<br><span class="hljs-comment"># .metadata: 存放元数据，来源数据（如文件名、页码 source, page）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;元数据: <span class="hljs-subst">&#123;page.metadata&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<pre><code class="hljs">==== 01 加载pdf文档====
数据类型: &lt;class &#39;list&#39;&gt;
总页数: 3
单页类型: &lt;class &#39;langchain_core.documents.base.Document&#39;&gt;
前500个字符: 第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个 Python 2D 绘图库，能够以多种硬拷⻉格式和跨平台的交互式环境⽣成出版物质量的图形，⽤来绘制各种静态，动态，
交互式的图表。
Matplotlib 可⽤于 Python 脚本， Python 和 IPython Shell 、 Jupyter notebook ， Web 应⽤程序服务器和各种图形⽤户界⾯⼯具包等。
Matplotlib 是 Python 数据可视化库中的泰⽃，它已经成为 python 中公认的数据可视化⼯具，我们所熟知的 pandas 和 seaborn 的绘图接⼝
其实也是基于 matplotlib 所作的⾼级封装。
为了对 matplotlib 有更好的理解，让我们从⼀些最基本的概念开始认识它，再逐渐过渡到⼀些⾼级技巧中。
⼆、⼀个最简单的绘图例⼦
Matplotlib 的图像是画在 figure （如 windows ， jupyter 窗体）上的，每⼀个 figure ⼜包含了⼀个或多个 axes （⼀个可以指定坐标系的⼦区
域）。最简单的创建 figu
元数据: &#123;&#39;producer&#39;: &#39;Skia/PDF m114&#39;, &#39;creator&#39;: &#39;Mozilla...&#39;, &#39;creationdate&#39;: &#39;2023-07-11T13:55:29+00:00&#39;, &#39;moddate&#39;: &#39;2023-07-12T10:54:28+08:00&#39;, &#39;source&#39;: &#39;docs/matplotlib/第一回：Matplotlib初相识.pdf&#39;, &#39;total_pages&#39;: 3, &#39;page&#39;: 0, &#39;page_label&#39;: &#39;1&#39;&#125;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==== 02 youtube音频 ====&quot;</span>)<br><span class="hljs-comment"># import sys</span><br><span class="hljs-comment"># # 确保引用路径包含 tool.py 所在的文件夹</span><br><span class="hljs-comment"># sys.path.append(&#x27;/home/py/shared/StudyChatgpt&#x27;)</span><br><br><span class="hljs-comment"># # 1. 从 tool.py 导入封装好的函数</span><br><span class="hljs-comment"># from tool import get_youtube_content</span><br><br><span class="hljs-comment"># # 2. 定义参数</span><br><span class="hljs-comment"># url = &quot;https://www.youtube.com/watch?v=_PHdzsQaDgw&quot;</span><br><span class="hljs-comment"># save_dir = &quot;docs/youtube-zh/&quot;</span><br><br><span class="hljs-comment"># # 3. 执行加载 (核心改动)</span><br><span class="hljs-comment"># # 之前那几十行定义 LocalWhisperParser 和 GenericLoader 的代码，</span><br><span class="hljs-comment"># # 现在全部被缩减为下面这一行函数调用：</span><br><span class="hljs-comment"># print(&quot;开始处理视频 (下载+转录)...&quot;)</span><br><span class="hljs-comment"># pages = get_youtube_content(url, save_dir=save_dir, model_size=&quot;base&quot;)</span><br><br><span class="hljs-comment"># # 4. 探索数据 (保留你原本的查看逻辑)</span><br><span class="hljs-comment"># print(f&quot;文档类型: &#123;type(pages)&#125;&quot;)</span><br><span class="hljs-comment"># print(f&quot;生成的文档数: &#123;len(pages)&#125;&quot;)</span><br><br><span class="hljs-comment"># if len(pages) &gt; 0:</span><br><span class="hljs-comment">#     page = pages[0]</span><br><span class="hljs-comment">#     print(f&quot;视频转录内容(前500字): &#123;page.page_content[:500]&#125;&quot;)</span><br><span class="hljs-comment">#     print(f&quot;元数据: &#123;page.metadata&#125;&quot;)</span><br><br><span class="hljs-comment"># 如果遇到 HTTP Error 403: Forbidden</span><br><span class="hljs-comment"># 第一步：强制更新 yt-dlp   pip install -U yt-dlp</span><br><span class="hljs-comment"># 第二步：修改 tool.py 增强伪装</span><br><span class="hljs-comment"># 如果更新后仍然报错 403，我们需要在代码中增加“伪装”，让 YouTube 以为我们是浏览器，而不是爬虫。</span><br><span class="hljs-comment"># 以上方法都不行</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment"># [v0.3 变化] 核心组件都在 community 包中</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders.generic <span class="hljs-keyword">import</span> GenericLoader<br><span class="hljs-keyword">from</span> langchain_community.document_loaders.blob_loaders.youtube_audio <span class="hljs-keyword">import</span> YoutubeAudioLoader<br><span class="hljs-keyword">from</span> langchain_community.document_loaders.base <span class="hljs-keyword">import</span> BaseBlobParser<br><span class="hljs-keyword">from</span> langchain_core.documents <span class="hljs-keyword">import</span> Document<br><span class="hljs-comment"># # --- 主逻辑 ---</span><br><span class="hljs-comment"># Stanford CS229： Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).m4a</span><br><span class="hljs-comment"># 1. 创建 GenericLoader (通用加载器)</span><br><span class="hljs-comment"># 语法：GenericLoader(下载器, 解析器)</span><br><span class="hljs-comment"># 含义：组合模式。先用 YoutubeAudioLoader 下载，再用 LocalWhisperParser 解析。</span><br><span class="hljs-comment"># loader = GenericLoader(&quot;docs/youtube/Stanford CS229： Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).m4a&quot;)</span><br><br><span class="hljs-comment"># 2. 执行加载</span><br><span class="hljs-comment"># 含义：触发下载 -&gt; 保存音频 -&gt; 调用 lazy_parse -&gt; 返回文档列表</span><br><br>pages = <span class="hljs-string">&quot;docs/youtube/Stanford CS229： Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).m4a&quot;</span><br><br><span class="hljs-comment"># 3. 探索数据</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文档类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(pages)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成的文档数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(pages)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pages) &gt; <span class="hljs-number">0</span>:<br>    page = pages[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;视频转录内容(前500字): <span class="hljs-subst">&#123;pages[:<span class="hljs-number">500</span>]&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;元数据: <span class="hljs-subst">&#123;pages&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">==== 02 youtube音频 ====
文档类型: &lt;class &#39;str&#39;&gt;
生成的文档数: 93
视频转录内容(前500字): docs/youtube/Stanford CS229： Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).m4a
元数据: docs/youtube/Stanford CS229： Machine Learning Course, Lecture 1 - Andrew Ng (Autumn 2018).m4a
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==== 03 网页文档 ====&quot;</span>)<br><span class="hljs-comment"># [v0.3 变化] 从 community 包导入</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> WebBaseLoader<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 1. 定义 URL 和 Header</span><br>url = <span class="hljs-string">&quot;https://github.com/datawhalechina/d2l-ai-solutions-manual/blob/master/docs/README.md&quot;</span><br><span class="hljs-comment"># 语法：字典结构，模拟浏览器请求头</span><br>header = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla...&#x27;</span><br>&#125;<br><br><span class="hljs-comment"># 2. 创建加载器</span><br><span class="hljs-comment"># 语法：指定 web_path 和 header_template</span><br>loader = WebBaseLoader(web_path=url, header_template=header)<br><br><span class="hljs-comment"># 3. 执行加载</span><br><span class="hljs-comment"># 含义：发送 HTTP 请求获取 HTML 源码，并包装成 Document</span><br>pages = loader.load()<br><br><span class="hljs-comment"># 4. 数据后处理 (Post-Processing)</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pages) &gt; <span class="hljs-number">0</span>:<br>    page = pages[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;原始页面长度: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(page.page_content)&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># [针对 GitHub Blob 页面的特殊清洗逻辑]</span><br>    <span class="hljs-comment"># GitHub 的 Blob 页面是 React 应用，内容包裹在 JSON 结构中</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 语法：json.loads() 将字符串转为字典</span><br>        convert_to_json = json.loads(page.page_content)<br>        <br>        <span class="hljs-comment"># 语法：多层字典取值，提取真正的 Markdown 内容</span><br>        extracted_markdown = convert_to_json[<span class="hljs-string">&#x27;payload&#x27;</span>][<span class="hljs-string">&#x27;blob&#x27;</span>][<span class="hljs-string">&#x27;richText&#x27;</span>]<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 提取后的 Markdown 内容 (前500字) ===&quot;</span>)<br>        <span class="hljs-built_in">print</span>(extracted_markdown[:<span class="hljs-number">500</span>])<br>        <br>    <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;解析 JSON 失败：页面可能不是 JSON 格式，或者是纯 HTML。&quot;</span>)<br>    <span class="hljs-keyword">except</span> KeyError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;提取失败：GitHub 页面结构可能已更新，找不到对应的 Key。&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">USER_AGENT environment variable not set, consider setting it to identify your requests.


==== 03 网页文档 ====
原始页面长度: 3900
解析 JSON 失败：页面可能不是 JSON 格式，或者是纯 HTML。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==== 04 Notion文档 ====&quot;</span>)<br><span class="hljs-comment"># [v0.3 变化] 从 community 包导入</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> NotionDirectoryLoader<br><br><span class="hljs-comment"># 1. 创建加载器</span><br><span class="hljs-comment"># 语法：指定包含 .md 文件的本地文件夹路径</span><br><span class="hljs-comment"># 注意：你需要先从 Notion 导出为 Markdown &amp; CSV 格式并解压到该目录</span><br>loader = NotionDirectoryLoader(<span class="hljs-string">&quot;docs/Notion_DB&quot;</span>)<br><br><span class="hljs-comment"># 2. 执行加载</span><br><span class="hljs-comment"># 含义：遍历文件夹，读取所有 Markdown 文件</span><br>pages = loader.load()<br><br><span class="hljs-comment"># 3. 探索数据</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;加载的 Notion 文档数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(pages)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pages) &gt; <span class="hljs-number">0</span>:<br>    page = pages[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文档类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(page)&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;内容摘要(前500字): <span class="hljs-subst">&#123;page.page_content[:<span class="hljs-number">500</span>]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># Notion Loader 的 metadata 通常包含文件名等信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;元数据: <span class="hljs-subst">&#123;page.metadata&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">==== 04 Notion文档 ====
加载的 Notion 文档数: 51
文档类型: &lt;class &#39;langchain_core.documents.base.Document&#39;&gt;
内容摘要(前500字): # Time off: holidays and national holidays

We kick off with the practical side of things and then dig into the idea behind it.

- **How *time off* works at Blendle**
    - Time off is about the time you **need,** not about a **quota.**
    - At Blendle, **HR doesn&#39;t keep track** of your holidays **and we don&#39;t &#39;pay out&#39; at the end of the ride.** When in doubt: 4-6 weeks is a good bandwidth. Less than that is not enough, more than that can happen, just check with your lead if you&#39;re in doubt if 
元数据: &#123;&#39;source&#39;: &#39;docs/Notion_DB/Time off holidays and national holidays dc2d206a3096412abe58e1db0ac79450.md&#39;&#125;
</code></pre>
<h2 id="第三章-文档切割-Document-Splitting"><a href="#第三章-文档切割-Document-Splitting" class="headerlink" title="第三章 文档切割 Document Splitting"></a>第三章 文档切割 Document Splitting</h2><p>在上一章中，我们刚刚讨论了如何将文档加载到标准格式中，现在我们要谈论如何将它们分割成较小的块。<br>一、为什么要进行文档分割<br>二、文档分割方式<br>三、基于字符分割<br>四、基于Token切割<br>五、分割Markdown文档</p>
<p>一、为什么要进行文档分割<br>模型大小和内存限制：GPT 模型，特别是大型版本如 GPT-3 或 GPT-4 ，具有数十亿甚至上百亿的参数。为了在一次前向传播中处理这么多的参数，需要大量的计算能力和内存。但是，大多数硬件设备（例如 GPU 或 TPU ）有内存限制。文档分割使模型能够在这些限制内工作。<br>计算效率：处理更长的文本序列需要更多的计算资源。通过将长文档分割成更小的块，可以更高效地进行计算。<br>序列长度限制：GPT 模型有一个固定的最大序列长度，例如2048个 token 。这意味着模型一次只能处理这么多 token 。对于超过这个长度的文档，需要进行分割才能被模型处理。<br>更好的泛化：通过在多个文档块上进行训练，模型可以更好地学习和泛化到各种不同的文本样式和结构。<br>数据增强：分割文档可以为训练数据提供更多的样本。例如，一个长文档可以被分割成多个部分，并分别作为单独的训练样本。<br>需要注意的是，虽然文档分割有其优点，但也可能导致一些上下文信息的丢失，尤其是在分割点附近。因此，如何进行文档分割是一个需要权衡的问题。<br>!(<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/llm-cookbook/figures/C4/document-splitting.png">https://datawhalechina.github.io/llm-cookbook/figures/C4/document-splitting.png</a>)<br>若仅按照单一字符进行文本分割，很容易使文本的语义信息丧失，这样在回答问题时可能会出现偏差。因此，为了确保语义的准确性，我们应该尽量将文本分割为包含完整语义的段落或单元。<br>二、文档分割方式<br>Langchain 中文本分割器都根据 chunk_size (块大小)和 chunk_overlap (块与块之间的重叠大小)进行分割。<br>!(<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/llm-cookbook/figures/C4/example-splitter.png">https://datawhalechina.github.io/llm-cookbook/figures/C4/example-splitter.png</a>)</p>
<p>chunk_size 指每个块包含的字符或 Token （如单词、句子等）的数量<br>chunk_overlap 指两个块之间共享的字符数量，用于保持上下文的连贯性，避免分割丢失上下文信息<br>!(<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/llm-cookbook/figures/C4/types-of-splitters.png">https://datawhalechina.github.io/llm-cookbook/figures/C4/types-of-splitters.png</a>)<br>Langchain提供多种文档分割方式，区别在怎么确定块与块之间的边界、块由哪些字符&#x2F;token组成、以及如何测量块大小。</p>
<p>三、基于字符分割<br>如何进行文本分割，往往与我们的任务类型息息相关。当我们拆分代码时，这种相关性变得尤为突出。因此，我们引入了一个语言文本分割器，其中包含各种为 Python、Ruby、C 等不同编程语言设计的分隔符。在对这些文档进行分割时，必须充分考虑各种编程语言之间的差异。</p>
<p>我们将从基于字符的分割开始探索，借助 LangChain 提供的 RecursiveCharacterTextSplitter 和 CharacterTextSplitter 工具来实现此目标。</p>
<p>CharacterTextSplitter 是字符文本分割，分隔符的参数是单个的字符串；<br>RecursiveCharacterTextSplitter 是递归字符文本分割，将按不同的字符递归地分割（按照这个优先级[“\n\n”, “\n”, “ “, “”]），这样就能尽量把所有和语义相关的内容尽可能长时间地保留在同一位置。<br>因此，RecursiveCharacterTextSplitter 比 CharacterTextSplitter 对文档切割得更加碎片化</p>
<p>RecursiveCharacterTextSplitter 需要关注的是如下4个参数：<br>separators - 分隔符字符串数组<br>chunk_size - 每个文档的字符数量限制<br>chunk_overlap - 两份文档重叠区域的长度<br>length_function - 长度计算函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 3.1 短句分割========&quot;</span>)<br><br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter, CharacterTextSplitter<br><br><span class="hljs-comment"># 定义切分参数</span><br>chunk_size = <span class="hljs-number">20</span>   <span class="hljs-comment"># 每个块包含的字符数（尽量靠近这个值）</span><br>chunk_overlap = <span class="hljs-number">10</span> <span class="hljs-comment"># 块与块之间重叠的字符数（防止语义在切分点丢失）</span><br><br><span class="hljs-comment"># 1. 初始化递归字符分割器 (推荐)</span><br><span class="hljs-comment"># 解释：它会尝试按顺序使用 [&quot;\n\n&quot;, &quot;\n&quot;, &quot; &quot;, &quot;&quot;] 分割，尽量保持段落、句子的完整性</span><br>r_splitter = RecursiveCharacterTextSplitter(<br>    chunk_size=chunk_size,<br>    chunk_overlap=chunk_overlap<br>)<br><br><span class="hljs-comment"># 2. 初始化普通字符分割器</span><br><span class="hljs-comment"># 解释：它只按照单一指定的分隔符切分，比较死板</span><br>c_splitter = CharacterTextSplitter(<br>    chunk_size=chunk_size,<br>    chunk_overlap=chunk_overlap,<br>    separator=<span class="hljs-string">&#x27;，&#x27;</span> <span class="hljs-comment"># 注意：这里显式指定了中文逗号，否则默认是换行符</span><br>)<br><br><span class="hljs-comment"># 测试文本</span><br>text = <span class="hljs-string">&quot;在AI的研究中，由于大模型规模非常大，模型参数很多，在大模型上跑完来验证参数好不好训练时间成本很高，所以一般会在小模型上做消融实验来验证哪些改进是有效的再去大模型上做实验。&quot;</span><br><br><span class="hljs-comment"># 3. 运行递归分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== 递归字符分割结果 ===&quot;</span>)<br><span class="hljs-comment"># 调用切割器对象 r_splitter 的 split_text 方法。</span><br><span class="hljs-comment"># 作用：将一个长字符串（text）按照设定的规则（如字符数限制）切割成多个较小的字符串片段。</span><br><span class="hljs-comment"># 结果：返回一个列表（List），里面包含切割好的所有文本块。</span><br>r_splits = r_splitter.split_text(text)<br><br><span class="hljs-comment"># 使用 enumerate 函数遍历刚刚生成的列表。</span><br><span class="hljs-keyword">for</span> i, chunk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(r_splits):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;块 <span class="hljs-subst">&#123;i&#125;</span>: <span class="hljs-subst">&#123;chunk&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 4. 运行字符分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 普通字符分割结果 ===&quot;</span>)<br>c_splits = c_splitter.split_text(text)<br><span class="hljs-keyword">for</span> i, chunk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(c_splits):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;块 <span class="hljs-subst">&#123;i&#125;</span>: <span class="hljs-subst">&#123;chunk&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">Created a chunk of size 23, which is longer than the specified 20


====== 3.1 短句分割========
=== 递归字符分割结果 ===
块 0: 在AI的研究中，由于大模型规模非常大，模
块 1: 大模型规模非常大，模型参数很多，在大模型
块 2: 型参数很多，在大模型上跑完来验证参数好不
块 3: 上跑完来验证参数好不好训练时间成本很高，
块 4: 好训练时间成本很高，所以一般会在小模型上
块 5: 所以一般会在小模型上做消融实验来验证哪些
块 6: 做消融实验来验证哪些改进是有效的再去大模
块 7: 改进是有效的再去大模型上做实验。

=== 普通字符分割结果 ===
块 0: 在AI的研究中，由于大模型规模非常大
块 1: 由于大模型规模非常大，模型参数很多
块 2: 在大模型上跑完来验证参数好不好训练时间成本很高
块 3: 所以一般会在小模型上做消融实验来验证哪些改进是有效的再去大模型上做实验。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 3.2 长文本分割========&quot;</span>)<br><span class="hljs-comment"># 定义长文本</span><br>some_text = <span class="hljs-string">&quot;&quot;&quot;在编写文档时，作者将使用文档结构对内容进行分组。 \</span><br><span class="hljs-string">    这可以向读者传达哪些想法是相关的。 例如，密切相关的想法\</span><br><span class="hljs-string">    是在句子中。 类似的想法在段落中。 段落构成文档。 \n\n\</span><br><span class="hljs-string">    段落通常用一个或两个回车符分隔。 \</span><br><span class="hljs-string">    回车符是您在该字符串中看到的嵌入的“反斜杠 n”。 \</span><br><span class="hljs-string">    句子末尾有一个句号，但也有一个空格。\</span><br><span class="hljs-string">    并且单词之间用空格分隔&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 1. 初始化普通字符分割器</span><br>c_splitter = CharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">80</span>,<br>    chunk_overlap=<span class="hljs-number">0</span>,<br>    separator=<span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-comment"># 强制按空格切分，会破坏中文语义，因为中文不靠空格分词</span><br>)<br><br><span class="hljs-comment"># 2. 初始化递归字符分割器</span><br><span class="hljs-comment"># 解释：separators 参数定义了优先级。</span><br><span class="hljs-comment"># 先找双换行，找不到找单换行，再找空格，最后强制切字符。</span><br>r_splitter = RecursiveCharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">80</span>,<br>    chunk_overlap=<span class="hljs-number">0</span>,<br>    separators=[<span class="hljs-string">&quot;\n\n&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文本总长度: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(some_text)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 执行分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 普通分割 (按空格) ---&quot;</span>)<br><span class="hljs-built_in">print</span>(c_splitter.split_text(some_text))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 递归分割 (智能) ---&quot;</span>)<br><span class="hljs-built_in">print</span>(r_splitter.split_text(some_text))<br><br><span class="hljs-comment"># 3. 进阶：使用正则进行句子级分割</span><br><span class="hljs-comment"># 解释：中文句号 &quot;。&quot; 后面通常没有空格，所以正则要写对。</span><br><span class="hljs-comment"># (?&lt;=...) 是“后发断言”，意思是匹配位置前面必须有句号，但句号本身不被消耗（保留在上一句末尾）。</span><br>r_splitter_regex = RecursiveCharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">30</span>,<br>    chunk_overlap=<span class="hljs-number">0</span>,<br>    separators=[<span class="hljs-string">&quot;\n\n&quot;</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;(?&lt;=\。)&quot;</span>, <span class="hljs-string">&quot;，&quot;</span>, <span class="hljs-string">&quot;&quot;</span>] <span class="hljs-comment"># 增加了句号和逗号</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 正则分割 (按标点) ---&quot;</span>)<br><span class="hljs-built_in">print</span>(r_splitter_regex.split_text(some_text))<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 3.2 长文本分割========
文本总长度: 177

--- 普通分割 (按空格) ---
[&#39;在编写文档时，作者将使用文档结构对内容进行分组。 这可以向读者传达哪些想法是相关的。 例如，密切相关的想法 是在句子中。 类似的想法在段落中。 段落构成文档。&#39;, &#39;段落通常用一个或两个回车符分隔。 回车符是您在该字符串中看到的嵌入的“反斜杠 n”。 句子末尾有一个句号，但也有一个空格。 并且单词之间用空格分隔&#39;]

--- 递归分割 (智能) ---
[&#39;在编写文档时，作者将使用文档结构对内容进行分组。     这可以向读者传达哪些想法是相关的。 例如，密切相关的想法    是在句子中。 类似的想法在段落中。&#39;, &#39;段落构成文档。&#39;, &#39;段落通常用一个或两个回车符分隔。     回车符是您在该字符串中看到的嵌入的“反斜杠 n”。     句子末尾有一个句号，但也有一个空格。&#39;, &#39;并且单词之间用空格分隔&#39;]

--- 正则分割 (按标点) ---
[&#39;在编写文档时&#39;, &#39;，作者将使用文档结构对内容进行分组。     这可以向读者传&#39;, &#39;达哪些想法是相关的。 例如&#39;, &#39;，密切相关的想法    是在句子中。 类似的想法在段落中。&#39;, &#39;段落构成文档。&#39;, &#39;段落通常用一个或两个回车符分隔。     回车符是&#39;, &#39;您在该字符串中看到的嵌入的“反斜杠 n”。     句子末尾&#39;, &#39;有一个句号&#39;, &#39;，但也有一个空格。    并且单词之间用空格分隔&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 基于 Token 分割========&quot;</span>)<br><span class="hljs-comment"># [v0.3 变化] 需安装 tiktoken 库: pip install tiktoken</span><br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> TokenTextSplitter<br><br><span class="hljs-comment"># 1. 初始化 Token 分割器</span><br><span class="hljs-comment"># 解释：chunk_size=1 表示每块只包含 1 个 Token（非常极端，仅做演示）</span><br>text_splitter = TokenTextSplitter(chunk_size=<span class="hljs-number">1</span>, chunk_overlap=<span class="hljs-number">0</span>)<br><br>text = <span class="hljs-string">&quot;foo bar bazzyfoo&quot;</span><br><br><span class="hljs-comment"># 2. 执行分割</span><br><span class="hljs-comment"># 注意：英文单词可能会被拆成词根，比如 bazzyfoo 可能会被拆成多个 token</span><br>tokens = text_splitter.split_text(text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Token 分割结果: <span class="hljs-subst">&#123;tokens&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># OpenAI 的 Tokenizer 对中文支持不是按照“字”来的，通常一个汉字对应 1.5 到 2 个 Token，或者有时多个字合并为一个 Token。</span><br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 基于 Token 分割========
Token 分割结果: [&#39;foo&#39;, &#39; bar&#39;, &#39; b&#39;, &#39;az&#39;, &#39;zy&#39;, &#39;foo&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======= 五、分割Markdown文档 ========&quot;</span>)<br><span class="hljs-comment"># [v0.3 变化] 导入 MarkdownHeaderTextSplitter</span><br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> MarkdownHeaderTextSplitter<br><br>markdown_document = <span class="hljs-string">&quot;&quot;&quot;# Title\n\n \</span><br><span class="hljs-string">## 第一章\n\n \</span><br><span class="hljs-string">李白乘舟将欲行\n\n 忽然岸上踏歌声\n\n \</span><br><span class="hljs-string">### Section \n\n \</span><br><span class="hljs-string">桃花潭水深千尺 \n\n </span><br><span class="hljs-string">## 第二章\n\n \</span><br><span class="hljs-string">不及汪伦送我情&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 1. 定义标题映射</span><br><span class="hljs-comment"># 解释：告诉分割器，# 是 Header 1, ## 是 Header 2...</span><br><span class="hljs-comment"># 这些信息会被提取出来放到 metadata 中，而不是留在正文里。</span><br>headers_to_split_on = [<br>    (<span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;Header 1&quot;</span>),<br>    (<span class="hljs-string">&quot;##&quot;</span>, <span class="hljs-string">&quot;Header 2&quot;</span>),<br>    (<span class="hljs-string">&quot;###&quot;</span>, <span class="hljs-string">&quot;Header 3&quot;</span>),<br>]<br><br><span class="hljs-comment"># 2. 初始化分割器</span><br>markdown_splitter = MarkdownHeaderTextSplitter(<br>    headers_to_split_on=headers_to_split_on<br>)<br><br><span class="hljs-comment"># 3. 执行分割</span><br>md_header_splits = markdown_splitter.split_text(markdown_document)<br><br><span class="hljs-comment"># 4. 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 第一个块 (包含元数据) ---&quot;</span>)<br><span class="hljs-comment"># 输出对象是 Document 类型</span><br><span class="hljs-comment"># page_content: 正文内容</span><br><span class="hljs-comment"># metadata: &#123;&#x27;Header 1&#x27;: &#x27;Title&#x27;, &#x27;Header 2&#x27;: &#x27;第一章&#x27;&#125;</span><br><span class="hljs-built_in">print</span>(md_header_splits[<span class="hljs-number">0</span>])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 第二个块 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(md_header_splits[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">======= 五、分割Markdown文档 ========
--- 第一个块 (包含元数据) ---
page_content=&#39;李白乘舟将欲行  
忽然岸上踏歌声&#39; metadata=&#123;&#39;Header 1&#39;: &#39;Title&#39;, &#39;Header 2&#39;: &#39;第一章&#39;&#125;

--- 第二个块 ---
page_content=&#39;桃花潭水深千尺&#39; metadata=&#123;&#39;Header 1&#39;: &#39;Title&#39;, &#39;Header 2&#39;: &#39;第一章&#39;, &#39;Header 3&#39;: &#39;Section&#39;&#125;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======5.2 分割数据库中的 Markdown 文档=======&quot;</span>)<br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> NotionDirectoryLoader<br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> MarkdownHeaderTextSplitter<br><br><span class="hljs-comment"># 1. 加载 Notion 数据</span><br><span class="hljs-comment"># 注意：确保 docs/Notion_DB 文件夹存在且有 .md 文件</span><br>loader = NotionDirectoryLoader(<span class="hljs-string">&quot;docs/Notion_DB&quot;</span>)<br><span class="hljs-comment"># loader.load(): 返回的是一个列表，比如 [Doc A, Doc B, Doc C]。</span><br><span class="hljs-comment"># &#x27; &#x27;.join(...): 这步操作把 Doc A、Doc B 和 Doc C 的内容全部拼成了一个巨大的字符串 txt。</span><br>docs = loader.load()<br><br><span class="hljs-comment"># 2. 拼接文档内容</span><br><span class="hljs-comment"># 解释：loader 加载出来的是 Document 对象列表。</span><br><span class="hljs-comment"># 这里简单粗暴地把所有页面的内容拼成了一个大字符串 txt</span><br>txt = <span class="hljs-string">&#x27; &#x27;</span>.join([d.page_content <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> docs])<br><br><span class="hljs-comment"># 3. 定义分割规则</span><br>headers_to_split_on = [<br>    (<span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;Header 1&quot;</span>),<br>    (<span class="hljs-string">&quot;##&quot;</span>, <span class="hljs-string">&quot;Header 2&quot;</span>),<br>]<br><br><span class="hljs-comment"># 4. 初始化分割器</span><br>markdown_splitter = MarkdownHeaderTextSplitter(<br>    headers_to_split_on=headers_to_split_on<br>)<br><br><span class="hljs-comment"># 5. 执行分割</span><br>md_header_splits = markdown_splitter.split_text(txt)<br><br><span class="hljs-comment"># 6. 查看结果</span><br><span class="hljs-keyword">if</span> md_header_splits:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n分割后第一块内容: <span class="hljs-subst">&#123;md_header_splits[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">100</span>]&#125;</span>...&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;分割后第一块元数据: <span class="hljs-subst">&#123;md_header_splits[<span class="hljs-number">0</span>].metadata&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">===分割数据库中的markdown文档====
page_content=&#39;We kick off with the practical side of things and then dig into the idea behind it.  
- **How *time off* works at Blendle**
- Time off is about the time you **need,** not about a **quota.**
- At Blendle, **HR doesn&#39;t keep track** of your holidays **and we don&#39;t &#39;pay out&#39; at the end of the ride.** When in doubt: 4-6 weeks is a good bandwidth. Less than that is not enough, more than that can happen, just check with your lead if you&#39;re in doubt if it&#39;s reasonable.
- **We stick to the commonly used national holidays**, which comes down to ~8 days per year. We are a startup and there are teams who have work to be done 24/7. We don&#39;t like being told whether we are off or not on Eid al-Fitr (Suikerfeest, ending of Ramadan) by some rules someone made up, so this is a guideline we use: feel free to work or be off when you want.
- Make sure to **take enough moments of rest when you have periods of working hard**. For example: worked a few nights to finish a project? Go home at 12:00 the next Monday to have lunch with a friend and go to the gym (or have a New Girl-marathon). It&#39;s about balance and flexibility.
- You agree on your time off with your team(lead).
- You put your time off in the agenda: add it to your own and all@ agenda.
- A life event occurs: communicate what you need and check with your team(lead) when in doubt. &#39;Hey I just had a baby, won&#39;t be at work this week, see you next week. His name is Jan by the way!&#39;.
- Enjoy: don&#39;t worry if you go to the gym or get a haircut during classic &#39;work hours&#39;. We trust you to make the best of your days for Blendle.
- **This only works when**
- Flexibility goes both ways.
- You make sure to take enough time off: since you don&#39;t get paid at the end of the ride.
- You communicate in a crystal clear manner: agreeing the dates with others and putting it in the agenda.
- **Backdrop**  
The law and additional ruling tell us what we can and can not do according to time off. We believe that is a very limited way of thinking about time off. We want you to think about what you actually need. Starting with two important pillars:  
- We work hard, we need time to reload and rest. Sometimes we work harder, so we need more. Some times we work less, so we need less.
- We have something called &#39;life&#39; happening which means we can&#39;t work because we have more important stuff to do.  
We want you to take enough rest to reload and recharge so you can be at your prime when working. Taking enough rest is as important as giving it your all when working. The well known on and off switch.  
The concept of work isn&#39;t always caught in time (40 hours) and place. Most of the people at Blendle don&#39;t keep track of time because time is such a limited variable to grasp the concept of work. There is a balance to strike here and just looking at hours or a holiday quota limits this discussion.  
**That is why we don&#39;t keep track of holidays.**  
Our people don&#39;t have a holiday quota, but a moral obligation to their loved ones and Blendle to work hard and take enough time to rest. Alright, sounds heavy. How does that work?  
&#39;Time off&#39; can be divided into two buckets:  
1. **Holidays and national holidays**:  
Your contract states you have 4 weeks of paid time off per year, by law.  
On average we have 8 national holidays per year. We have no CAO (collective employment agreement), which means you are not entitled to paid time off on every national holiday. We decided to follow the most common situation in an average company, which in practice means most people are off on the big national holidays. But that&#39;s your own choice, it&#39;s not a right or an obligation, so feel free to improvise. Some teams even have to (editorial and support, for example).  
These rules state that we are off on &#39;Bevrijdingsdag&#39; once every 5 years. But we aren&#39;t allowed time off on Eid al-Fitr (Suikerfeest, ending of the Ramadan). That makes no sense to us.  
So here is how we approach holidays and national holidays in practice.  
You &#39;have&#39; 5 weeks holiday and ~8 national holidays per year. We want you to use this time off to reload but you decide when and how to consume this. You must also feel free to improvise. You work hard, maybe even a bit too hard, so you might need some extra time off to stay happy and healthy. This also works the other way around: maybe you had a chill quarter and feel no need to take a holiday: feel free to do so. We want you to think about what your body and mind needs instead of your quota.  
2. **Life events:**  
Life happens. Your cat dies, your car broke, you move to another city, you get married or have kids. Life events which all need your attention. We decided that we are not going to decide for you how much time you **get** for certain events. The question is: how much time do you actually **need.**  
Most companies don&#39;t give you time off for funerals that are not for immediate relatives. We think we don&#39;t need a rule to tell us if that funeral is important for you. So take the time you need.  
- Edge cases
- Sabbatical: check with HR if you for example have plans to take a very long trip (longer then ~4 weeks).&#39; metadata=&#123;&#39;Header 1&#39;: &#39;Time off: holidays and national holidays&#39;&#125;
</code></pre>
<p>如果按照上面的全部文档一起切割，会造成：<br>元数据丢失：Doc A 原本的文件名、路径等元数据（Metadata）在这里全部丢弃了。<br>边界模糊：如果 Doc A 的结尾没有标题，Doc B 的开头也没有标题，它们的内容会直接粘在一起，LLM 可能会以为它们是同一篇文章。<br>标题混淆：如果 Doc A 有个一级标题 # 介绍，Doc B 也有个 # 介绍，拼在一起后，分割器会把它们当成同一个大章节下的内容处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======5.3 逐个分割数据库中的 Markdown 文档 =======&quot;</span>)<br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> NotionDirectoryLoader<br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> MarkdownHeaderTextSplitter<br><br><span class="hljs-comment"># 1. 加载数据</span><br>loader = NotionDirectoryLoader(<span class="hljs-string">&quot;docs/Notion_DB&quot;</span>)<br>docs = loader.load()<br><br><span class="hljs-comment"># 2. 定义分割规则</span><br>headers_to_split_on = [<br>    (<span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;Header 1&quot;</span>),<br>    (<span class="hljs-string">&quot;##&quot;</span>, <span class="hljs-string">&quot;Header 2&quot;</span>),<br>    (<span class="hljs-string">&quot;###&quot;</span>, <span class="hljs-string">&quot;Header 3&quot;</span>),<br>]<br>markdown_splitter = MarkdownHeaderTextSplitter(<br>    headers_to_split_on=headers_to_split_on<br>)<br><br><span class="hljs-comment"># 3. 逐个处理文档 (修正逻辑)</span><br>all_splits = []<br><br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>    <span class="hljs-comment"># doc 是一个 Document 对象，包含 page_content 和 metadata</span><br>    <br>    <span class="hljs-comment"># 对当前这一个文档进行分割</span><br>    splits = markdown_splitter.split_text(doc.page_content)<br>    <br>    <span class="hljs-comment"># 关键步骤：把原始文档的元数据（如文件名）合并到分割后的块中</span><br>    <span class="hljs-comment"># 这样你就知道这一块内容具体来自哪个文件了</span><br>    <span class="hljs-keyword">for</span> split <span class="hljs-keyword">in</span> splits:<br>        split.metadata.update(doc.metadata)<br>        all_splits.append(split)<br><br><span class="hljs-comment"># 4. 查看结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;原始文档数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;分割后的块数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(all_splits)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> all_splits:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 示例块 ---&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;内容: <span class="hljs-subst">&#123;all_splits[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">50</span>]&#125;</span>...&quot;</span>)<br>    <span class="hljs-comment"># 这里你会看到既有 Headers 信息，也有原始的文件 source 信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;元数据: <span class="hljs-subst">&#123;all_splits[<span class="hljs-number">0</span>].metadata&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">======5.3 逐个分割数据库中的 Markdown 文档 =======
原始文档数量: 51
分割后的块数量: 140

--- 示例块 ---
内容: We kick off with the practical side of things and ...
元数据: &#123;&#39;Header 1&#39;: &#39;Time off: holidays and national holidays&#39;, &#39;source&#39;: &#39;docs/Notion_DB/Time off holidays and national holidays dc2d206a3096412abe58e1db0ac79450.md&#39;&#125;
</code></pre>
<h2 id="第四章-向量数据库与词向量-Vectorstores-and-Embeddings"><a href="#第四章-向量数据库与词向量-Vectorstores-and-Embeddings" class="headerlink" title="第四章 向量数据库与词向量 Vectorstores and Embeddings"></a>第四章 向量数据库与词向量 Vectorstores and Embeddings</h2><p>检索增强生成（RAG）的整体工作流程：<br>!(<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/llm-cookbook/figures/C4/overview.png">https://datawhalechina.github.io/llm-cookbook/figures/C4/overview.png</a>)<br>一、读取文档<br>二、Embeddings<br>三、Vectorstores<br>四、失败的情况(Failure modes)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== 一、读取文档 ====&quot;</span>)<br><span class="hljs-comment"># [v0.3] 从 community 包导入 PDF 加载器</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> PyPDFLoader<br><span class="hljs-comment"># [v0.3] 从 text_splitters 包导入分割器 (推荐做法)</span><br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><br><span class="hljs-comment"># 1. 定义文件路径</span><br><span class="hljs-comment"># 这里为了演示“重复块”的问题，故意重复加载了第一个文档</span><br>loaders = [<br>    PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第一回：Matplotlib初相识.pdf&quot;</span>),<br>    PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第一回：Matplotlib初相识.pdf&quot;</span>), <span class="hljs-comment"># 重复</span><br>    PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第二回：艺术画笔见乾坤.pdf&quot;</span>),<br>    PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第三回：布局格式定方圆.pdf&quot;</span>)<br>]<br><br><span class="hljs-comment"># 2. 加载文档</span><br>docs = []<br><span class="hljs-keyword">for</span> loader <span class="hljs-keyword">in</span> loaders:<br>    <span class="hljs-comment"># loader.load() 返回 Document 对象列表</span><br>    docs.extend(loader.load())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;原始页面数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 3. 分割文本</span><br><span class="hljs-comment"># 初始化分割器：每块 1500 字符，重叠 150 字符</span><br>text_splitter = RecursiveCharacterTextSplitter(<br>    chunk_size=<span class="hljs-number">1500</span>,<br>    chunk_overlap=<span class="hljs-number">150</span><br>)<br><br><span class="hljs-comment"># 执行分割</span><br>splits = text_splitter.split_documents(docs)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;分割后的块数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(splits)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">=== 一、读取文档 ====
原始页面数量: 24
分割后的块数量: 27
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== 二、Embeddings (向量化) ====&quot;</span>)<br><span class="hljs-comment"># [v0.3] 必须从 langchain_openai 导入</span><br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;/home/py/shared/StudyChatgpt&#x27;</span>)<br><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_embedding_model<br><span class="hljs-comment"># 1. 初始化 Embedding 模型   get_embedding_model使用本地模型</span><br><span class="hljs-comment"># 这一步会使用 OPENAI_API_KEY 环境变量</span><br>embedding = get_embedding_model()<br><br><span class="hljs-comment"># 2. 测试文本</span><br>sentence1 = <span class="hljs-string">&quot;我喜欢狗&quot;</span><br>sentence2 = <span class="hljs-string">&quot;我喜欢犬科动物&quot;</span><br>sentence3 = <span class="hljs-string">&quot;外面的天气很糟糕&quot;</span><br><br><span class="hljs-comment"># 3. 生成向量 (embed_query)</span><br><span class="hljs-comment"># 这会将文本转化为一个长度为 1536 的浮点数列表</span><br><span class="hljs-comment"># 将单条查询文本转换为向量。如果是处理大量文档，通常底层会调用 embed_documents</span><br>embedding1 = embedding.embed_query(sentence1)<br>embedding2 = embedding.embed_query(sentence2)<br>embedding3 = embedding.embed_query(sentence3)<br><span class="hljs-comment"># embedding.embed_documents([sentence1, sentence2, sentence3])    </span><br><br><span class="hljs-comment"># 4. 计算相似度 (点积 Dot Product)</span><br><span class="hljs-comment"># 在向量归一化的情况下，点积等同于余弦相似度。值越接近 1 表示越相似。</span><br>score_1_2 = np.dot(embedding1, embedding2)<br>score_1_3 = np.dot(embedding1, embedding3)<br>score_2_3 = np.dot(embedding2, embedding3)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;句子1 vs 句子2 (相似): <span class="hljs-subst">&#123;score_1_2:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>) <span class="hljs-comment"># 期望高分 (e.g., &gt; 0.9)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;句子1 vs 句子3 (无关): <span class="hljs-subst">&#123;score_1_3:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>) <span class="hljs-comment"># 期望低分 (e.g., &lt; 0.8)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;句子2 vs 句子3 (无关): <span class="hljs-subst">&#123;score_2_3:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">=== 二、Embeddings (向量化) ====
🚀 正在从本地缓存加载模型: BAAI/bge-base-zh-v1.5 ...
✅ 模型加载成功！
句子1 vs 句子2 (相似): 0.8826
句子1 vs 句子3 (无关): 0.3493
句子2 vs 句子3 (无关): 0.3381
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== 三、Vectorstores (向量数据库- Chroma) ====&quot;</span>)<br><span class="hljs-comment"># [v0.3] 必须从 langchain_chroma 导入</span><br><span class="hljs-keyword">from</span> langchain_chroma <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 定义持久化路径</span><br>persist_directory = <span class="hljs-string">&#x27;docs/chroma/matplotlib/&#x27;</span><br><br><span class="hljs-comment"># 0. 清理旧数据 (可选)</span><br><span class="hljs-comment"># 如果该文件夹存在，先删除，防止旧数据干扰</span><br><span class="hljs-keyword">if</span> os.path.exists(persist_directory):<br>    shutil.rmtree(persist_directory)<br><br><span class="hljs-comment"># 1. 创建并初始化向量数据库</span><br><span class="hljs-comment"># from_documents 会自动做三件事：</span><br><span class="hljs-comment"># a. 调用 embedding 模型将所有 splits 向量化</span><br><span class="hljs-comment"># b. 将向量和原文本存入 Chroma</span><br><span class="hljs-comment"># c. 保存到磁盘 (persist_directory)</span><br>vectordb = Chroma.from_documents(   <span class="hljs-comment"># 工厂方法，是从零构建向量库的标准入口</span><br>    documents=splits,<br>    embedding=embedding,<br>    persist_directory=persist_directory  <span class="hljs-comment"># 持久化储存：指定这个参数后，Chroma 会以 SQLite 文件形式保存在硬盘上。下次你可以直接加载这个目录，而不需要重新 Embedding 所有文档。</span><br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据库中文档数量: <span class="hljs-subst">&#123;vectordb._collection.count()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 2. 相似性搜索 (Similarity Search)</span><br>question = <span class="hljs-string">&quot;Matplotlib是什么？&quot;</span><br><br><span class="hljs-comment"># 搜索最相似的 3 个片段</span><br>docs_result = vectordb.similarity_search(question, k=<span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n找到相关文档数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs_result)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- 最佳答案片段 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(docs_result[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">200</span>]) <span class="hljs-comment"># 打印前200字</span><br><br><span class="hljs-comment"># [注意]持久化向量数据库: 在新版 Chroma 中，数据会在写入时自动保存，不需要调用 vectordb.persist()</span><br></code></pre></td></tr></table></figure>

<pre><code class="hljs">=== 三、Vectorstores (向量数据库- Chroma) ====
数据库中文档数量: 27

找到相关文档数: 3
--- 最佳答案片段 ---
第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个 Python 2D 绘图库，能够以多种硬拷⻉格式和跨平台的交互式环境⽣成出版物质量的图形，⽤来绘制各种静态，动态，
交互式的图表。
Matplotlib 可⽤于 Python 脚本， Python 和 IPython Shell 、 Jupyter notebook ， Web 应⽤程序服务器和各
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 演示：相似度搜索的缺陷 (重复内容) ===&quot;</span>)<br><br><span class="hljs-comment"># 我们再次搜索，这次找前 5 个结果</span><br><span class="hljs-comment"># 由于我们在第一步故意加载了两遍 &quot;第一回.pdf&quot;，这里会看到重复结果</span><br>question = <span class="hljs-string">&quot;Matplotlib是什么？&quot;</span><br>docs_duplicate = vectordb.similarity_search(question, k=<span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文档 1 来源: <span class="hljs-subst">&#123;docs_duplicate[<span class="hljs-number">0</span>].metadata[<span class="hljs-string">&#x27;source&#x27;</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文档 2 来源: <span class="hljs-subst">&#123;docs_duplicate[<span class="hljs-number">1</span>].metadata[<span class="hljs-string">&#x27;source&#x27;</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 验证内容是否完全一致</span><br><span class="hljs-keyword">if</span> docs_duplicate[<span class="hljs-number">0</span>].page_content == docs_duplicate[<span class="hljs-number">1</span>].page_content:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n⚠️ 警告: 检测到重复的检索结果！&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原因: 简单的 similarity_search 只是按分数排序，不进行去重。&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;后果: 浪费 LLM 的上下文窗口，且信息单一。&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 文档 1 内容摘要 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(docs_duplicate[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">100</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- 文档 2 内容摘要 ---&quot;</span>)<br><span class="hljs-built_in">print</span>(docs_duplicate[<span class="hljs-number">1</span>].page_content[:<span class="hljs-number">100</span>])<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 演示：相似度搜索的缺陷 (重复内容) ===
文档 1 来源: docs/matplotlib/第一回：Matplotlib初相识.pdf
文档 2 来源: docs/matplotlib/第一回：Matplotlib初相识.pdf

⚠️ 警告: 检测到重复的检索结果！
原因: 简单的 similarity_search 只是按分数排序，不进行去重。
后果: 浪费 LLM 的上下文窗口，且信息单一。

--- 文档 1 内容摘要 ---
第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个 Python 2D 绘图库，能够以多种硬拷⻉格式和跨平台的交互式环境⽣成出版物质量的图形，⽤来绘制

--- 文档 2 内容摘要 ---
第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个 Python 2D 绘图库，能够以多种硬拷⻉格式和跨平台的交互式环境⽣成出版物质量的图形，⽤来绘制
</code></pre>
<h2 id="第五章-检索-Retrieval"><a href="#第五章-检索-Retrieval" class="headerlink" title="第五章 检索 Retrieval"></a>第五章 检索 Retrieval</h2><p>在构建检索增强生成 (RAG) 系统时，信息检索是核心环节。检索模块负责对用户查询进行分析，从知识库中快速定位相关文档或段落，为后续的语言生成提供信息支持。检索是指根据用户的问题去向量数据库中搜索与问题相关的文档内容，当我们访问和查询向量数据库时可能会运用到如下几种技术：</p>
<p>基本语义相似度(Basic semantic similarity)<br>最大边际相关性(Maximum marginal relevance，MMR)<br>过滤元数据<br>LLM辅助检索</p>
<p>!(<a target="_blank" rel="noopener" href="https://datawhalechina.github.io/llm-cookbook/figures/C4/Retrieval.png">https://datawhalechina.github.io/llm-cookbook/figures/C4/Retrieval.png</a>)<br>使用基本的相似性搜索大概能解决你80%的相关检索工作，但对于那些相似性搜索失败的边缘情况该如何解决呢？这一章节我们将介绍几种检索方法，以及解决检索边缘情况的技巧，让我们一起开始学习吧！<br>一、向量数据库检索<br>二、结合各种技术<br>三、其他类型的检索<br>四、总结</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment"># 将 tool.py 所在目录加入路径</span><br>sys.path.append(<span class="hljs-string">&#x27;/home/py/shared/StudyChatgpt&#x27;</span>)<br><br><span class="hljs-comment"># 从 tool.py 导入你的本地模型函数</span><br><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_embedding_model, get_chat_model2<br><br><span class="hljs-comment"># 1. 获取本地 Embedding 模型 (BAAI/bge-base-zh-v1.5)</span><br>embedding_model = get_embedding_model()<br><br><span class="hljs-comment"># 2. 获取本地 LLM 模型 (Qwen/Qwen2.5-7B-Instruct)</span><br>llm_model = get_chat_model2()<br></code></pre></td></tr></table></figure>

<p>1.1 相似性检索 (Similarity Search)<br>首先加载之前课程保存的 Matplotlib 向量库，并创建一个临时的“蘑菇数据库”来演示基础检索。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [v0.3 变化] Chroma 现在位于 langchain_chroma 包中</span><br><span class="hljs-keyword">from</span> langchain_chroma <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain_core.documents <span class="hljs-keyword">import</span> Document<br><br><span class="hljs-comment"># --- 加载已有的 Matplotlib 向量库 ---</span><br>persist_directory = <span class="hljs-string">&#x27;docs/chroma/matplotlib/&#x27;</span> <span class="hljs-comment"># 假设这是你上一节课保存的路径</span><br><br><span class="hljs-comment"># 初始化 Chroma</span><br><span class="hljs-comment"># 含义：加载硬盘上的向量数据库，使用本地 Embedding 模型进行向量计算</span><br><span class="hljs-comment"># Chroma(...): 实例化向量库对象。关键参数是 embedding_function，它决定了如何把问题变成向量。</span><br>vectordb_matplotlib = Chroma(<br>    persist_directory=persist_directory,<br>    embedding_function=embedding_model<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Matplotlib 库文档数: <span class="hljs-subst">&#123;vectordb_matplotlib._collection.count()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 创建临时的蘑菇数据库 (用于演示) ---</span><br>texts = [<br>    <span class="hljs-string">&quot;毒鹅膏菌（Amanita phalloides）具有大型且引人注目的地上（epigeous）子实体（basidiocarp）&quot;</span>,<br>    <span class="hljs-string">&quot;一种具有大型子实体的蘑菇是毒鹅膏菌（Amanita phalloides）。某些品种全白。&quot;</span>,<br>    <span class="hljs-string">&quot;A. phalloides，又名死亡帽，是已知所有蘑菇中最有毒的一种。&quot;</span>,<br>]<br><br><span class="hljs-comment"># from_texts: 直接从字符串列表创建临时的内存向量库</span><br>smalldb = Chroma.from_texts(texts, embedding=embedding_model)<br><br><span class="hljs-comment"># 定义问题</span><br>question = <span class="hljs-string">&quot;告诉我关于具有大型子实体的全白色蘑菇的信息&quot;</span><br><br><span class="hljs-comment"># 执行相似度搜索</span><br><span class="hljs-comment"># k=2: 只返回最相似的前 2 个结果</span><br>docs = smalldb.similarity_search(question, k=<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.1 相似性检索结果 ===&quot;</span>)<br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>    <span class="hljs-built_in">print</span>(doc.page_content)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">Matplotlib 库文档数: 27

=== 1.1 相似性检索结果 ===
一种具有大型子实体的蘑菇是毒鹅膏菌（Amanita phalloides）。某些品种全白。
毒鹅膏菌（Amanita phalloides）具有大型且引人注目的地上（epigeous）子实体（basidiocarp）
</code></pre>
<p>你会发现返回的前两句意思几乎一样（冗余）。</p>
<p>1.2 解决多样性：最大边际相关性 (MMR)<br>为了解决上面提到的“冗余”问题（返回了两个意思几乎一样的句子），我们使用 MMR 算法。</p>
<p>MMR 原理：它不仅看“和问题像不像”，还看“和已经选出来的答案像不像”。如果第二个答案和第一个答案太像，MMR 就会把它踢掉，选一个不那么像但包含新信息的答案。<br>效果：这里应该会返回第一句（最相关）和第三句（关于“有毒”的信息），而不是返回两句都说“大型子实体”的废话。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.2 MMR 多样性检索结果 ===&quot;</span>)<br><br><span class="hljs-comment"># max_marginal_relevance_search: MMR 搜索</span><br><span class="hljs-comment"># k=2: 最终返回 2 个结果</span><br><span class="hljs-comment"># fetch_k=3: 先从数据库里找最相似的 3 个候选项，</span><br><span class="hljs-comment"># 再从中筛选出差异最大的 2 个</span><br>docs_mmr = smalldb.max_marginal_relevance_search(question, k=<span class="hljs-number">2</span>, fetch_k=<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs_mmr:<br>    <span class="hljs-built_in">print</span>(doc.page_content)<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 1.2 MMR 多样性检索结果 ===
一种具有大型子实体的蘑菇是毒鹅膏菌（Amanita phalloides）。某些品种全白。
A. phalloides，又名死亡帽，是已知所有蘑菇中最有毒的一种。
</code></pre>
<p>1.3 解决特殊性：使用元数据 (Metadata Filtering)<br>演示如何手动过滤特定来源的文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.3 手动元数据过滤 ===&quot;</span>)<br><br>question_matplotlib = <span class="hljs-string">&quot;他们在第二讲中对Figure说了些什么？&quot;</span><br><br><span class="hljs-comment"># filter 参数：Chroma 特有的过滤语法</span><br><span class="hljs-comment"># 含义：只在 metadata[&#x27;source&#x27;] 等于指定路径的文档中进行搜索   类似于 sql 的 where 条件附加</span><br>docs_filtered = vectordb_matplotlib.similarity_search(<br>    question_matplotlib,<br>    k=<span class="hljs-number">3</span>,<br>    <span class="hljs-built_in">filter</span>=&#123;<span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-string">&quot;docs/matplotlib/第二回：艺术画笔见乾坤.pdf&quot;</span>&#125;<br>)<br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> docs_filtered:<br>    <span class="hljs-comment"># 打印元数据以验证来源</span><br>    <span class="hljs-built_in">print</span>(d.metadata)<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 1.3 手动元数据过滤 ===
&#123;&#39;page_label&#39;: &#39;10&#39;, &#39;page&#39;: 9, &#39;producer&#39;: &#39;Skia/PDF m114&#39;, &#39;creator&#39;: &#39;Mozilla...&#39;, &#39;total_pages&#39;: 13, &#39;source&#39;: &#39;docs/matplotlib/第二回：艺术画笔见乾坤.pdf&#39;, &#39;moddate&#39;: &#39;2023-07-12T10:54:41+08:00&#39;, &#39;creationdate&#39;: &#39;2023-07-11T13:58:07+00:00&#39;&#125;
&#123;&#39;page_label&#39;: &#39;11&#39;, &#39;total_pages&#39;: 13, &#39;producer&#39;: &#39;Skia/PDF m114&#39;, &#39;moddate&#39;: &#39;2023-07-12T10:54:41+08:00&#39;, &#39;source&#39;: &#39;docs/matplotlib/第二回：艺术画笔见乾坤.pdf&#39;, &#39;page&#39;: 10, &#39;creator&#39;: &#39;Mozilla...&#39;, &#39;creationdate&#39;: &#39;2023-07-11T13:58:07+00:00&#39;&#125;
&#123;&#39;producer&#39;: &#39;Skia/PDF m114&#39;, &#39;moddate&#39;: &#39;2023-07-12T10:54:41+08:00&#39;, &#39;creationdate&#39;: &#39;2023-07-11T13:58:07+00:00&#39;, &#39;source&#39;: &#39;docs/matplotlib/第二回：艺术画笔见乾坤.pdf&#39;, &#39;creator&#39;: &#39;Mozilla...&#39;, &#39;page_label&#39;: &#39;2&#39;, &#39;total_pages&#39;: 13, &#39;page&#39;: 1&#125;
</code></pre>
<p>1.4 解决特殊性：自查询检索器 (SelfQueryRetriever)<br>这是最核心的改动。我们将使用本地 LLM (Qwen) 来代替 OpenAI，自动分析用户意图并构建过滤条件。</p>
<p>注意：Qwen 这样的通用模型在输出严格的结构化查询语句时可能不如 GPT-4 稳定，但 SelfQueryRetriever 在 v0.3 中依然可用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [v0.3 变化] 导入路径调整</span><br><span class="hljs-keyword">from</span> langchain.chains.query_constructor.base <span class="hljs-keyword">import</span> AttributeInfo<br><span class="hljs-keyword">from</span> langchain.retrievers.self_query.base <span class="hljs-keyword">import</span> SelfQueryRetriever<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.4 自查询检索器 (LLM 自动过滤) ===&quot;</span>)<br><br><span class="hljs-comment"># 1. 定义元数据字段描述</span><br><span class="hljs-comment"># 这一步是告诉 LLM：我的数据库里有哪些字段可以用来过滤</span><br>metadata_field_info = [<br>    AttributeInfo(<br>        name=<span class="hljs-string">&quot;source&quot;</span>,<br>        description=<span class="hljs-string">&quot;课堂讲义的来源文件路径，应该是以下之一: `docs/matplotlib/第一回：Matplotlib初相识.pdf`, `docs/matplotlib/第二回：艺术画笔见乾坤.pdf`, `docs/matplotlib/第三回：布局格式定方圆.pdf`&quot;</span>,<br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span>,<br>    ),<br>    <span class="hljs-comment"># AttributeInfo(</span><br>    <span class="hljs-comment">#     name=&quot;page&quot;,</span><br>    <span class="hljs-comment">#     description=&quot;讲义所在的页码&quot;,</span><br>    <span class="hljs-comment">#     type=&quot;integer&quot;,</span><br>    <span class="hljs-comment"># ),</span><br>]<br><br>document_content_description = <span class="hljs-string">&quot;Matplotlib 课堂讲义&quot;</span><br><br><span class="hljs-comment"># 2. 构建自查询检索器</span><br><span class="hljs-comment"># from_llm: 工厂方法，组合 LLM、向量库和元数据描述</span><br>retriever_self_query = SelfQueryRetriever.from_llm(<br>    llm_model, <span class="hljs-comment"># 使用 Qwen 本地模型</span><br>    vectordb_matplotlib,  <span class="hljs-comment"># 向量数据库</span><br>    document_content_description,<br>    metadata_field_info,<br>    verbose=<span class="hljs-literal">True</span> <span class="hljs-comment"># 开启 verbose 可以看到 LLM 生成了什么样的过滤语句</span><br>)<br><br><span class="hljs-comment"># 3. 提问</span><br>question_self = <span class="hljs-string">&quot;他们在第二讲中对Figure做了些什么？&quot;</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># invoke: v0.3 标准调用方式</span><br>    docs_self = retriever_self_query.invoke(question_self)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;检索到的文档数量: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs_self)&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> docs_self:<br>        <span class="hljs-built_in">print</span>(d.metadata)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;自查询失败 (可能是本地模型生成的查询语法解析错误): <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 1.4 自查询检索器 (LLM 自动过滤) ===
检索到的文档数量: 0
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chains.query_constructor.base <span class="hljs-keyword">import</span> AttributeInfo, load_query_constructor_runnable<br><span class="hljs-keyword">from</span> langchain.retrievers.self_query.base <span class="hljs-keyword">import</span> SelfQueryRetriever<br><span class="hljs-comment"># [v0.3 关键] 引入结构化查询翻译器 (解释器)</span><br><span class="hljs-keyword">from</span> langchain.chains.query_constructor.ir <span class="hljs-keyword">import</span> StructuredQuery<br><span class="hljs-keyword">from</span> langchain.retrievers.self_query.chroma <span class="hljs-keyword">import</span> ChromaTranslator<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.4 自查询检索器 (显式构建版) ===&quot;</span>)<br><br><span class="hljs-comment"># 1. 定义元数据字段 (保持不变)</span><br>metadata_field_info = [<br>    AttributeInfo(<br>        name=<span class="hljs-string">&quot;source&quot;</span>,<br>        description=<span class="hljs-string">&quot;课堂讲义的来源文件路径，应该是以下之一: `docs/matplotlib/第一回：Matplotlib初相识.pdf`, `docs/matplotlib/第二回：艺术画笔见乾坤.pdf`, `docs/matplotlib/第三回：布局格式定方圆.pdf`&quot;</span>,<br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;string&quot;</span>,<br>    ),<br>    AttributeInfo(<br>        name=<span class="hljs-string">&quot;page&quot;</span>,<br>        description=<span class="hljs-string">&quot;讲义所在的页码&quot;</span>,<br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;integer&quot;</span>,<br>    ),<br>]<br><br>document_content_description = <span class="hljs-string">&quot;Matplotlib 课堂讲义&quot;</span><br><br><span class="hljs-comment"># 2. 定义示例 (Few-Shot Examples) - 教 LLM 怎么写 and()</span><br><span class="hljs-comment"># Qwen 本地模型非常需要这个，否则它会写错语法</span><br>examples = [<br>    (<br>        <span class="hljs-string">&quot;第二讲里关于Figure的内容&quot;</span>,<br>        &#123;<br>            <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;Figure&quot;</span>,<br>            <span class="hljs-string">&quot;filter&quot;</span>: <span class="hljs-string">&quot;eq(\&quot;source\&quot;, \&quot;docs/matplotlib/第二回：艺术画笔见乾坤.pdf\&quot;)&quot;</span><br>        &#125;<br>    ),<br>    (<br>        <span class="hljs-string">&quot;第二讲第1页关于颜色的内容&quot;</span>,<br>        &#123;<br>            <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;颜色&quot;</span>,<br>            <span class="hljs-string">&quot;filter&quot;</span>: <span class="hljs-string">&quot;and(eq(\&quot;source\&quot;, \&quot;docs/matplotlib/第二回：艺术画笔见乾坤.pdf\&quot;), eq(\&quot;page\&quot;, 1))&quot;</span><br>        &#125;<br>    )<br>]<br><br><span class="hljs-comment"># 3. [核心修改] 第一步：构建查询构造器 (Chain)</span><br><span class="hljs-comment"># 我们直接调用 load_query_constructor_runnable，这个函数允许直接传 &#x27;examples&#x27; 或 &#x27;prompt&#x27;</span><br><span class="hljs-comment"># 这样就避开了 from_llm 中 chain_kwargs 的校验坑</span><br>query_constructor = load_query_constructor_runnable(<br>    llm=llm_model,<br>    document_contents=document_content_description,<br>    attribute_info=metadata_field_info,<br>    examples=examples, <span class="hljs-comment"># 直接传示例，它会自动帮我们生成 Prompt</span><br>    <span class="hljs-comment"># 如果你想用之前自定义的 prompt，也可以传 prompt=prompt</span><br>)<br><br><span class="hljs-comment"># 4. [核心修改] 第二步：构建检索器</span><br><span class="hljs-comment"># 使用基础构造函数 __init__，而不是 from_llm</span><br>retriever_self_query = SelfQueryRetriever(<br>    query_constructor=query_constructor, <span class="hljs-comment"># 传入刚才建好的链</span><br>    vectorstore=vectordb_matplotlib,     <span class="hljs-comment"># 传入向量库</span><br>    structured_query_translator=ChromaTranslator(), <span class="hljs-comment"># [v0.3] 显式指定 Chroma 翻译器</span><br>    verbose=<span class="hljs-literal">True</span><br>)<br><br><span class="hljs-comment"># 5. 提问</span><br>question_self = <span class="hljs-string">&quot;他们在第二讲中对Figure做了些什么？&quot;</span><br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在提问: <span class="hljs-subst">&#123;question_self&#125;</span>&quot;</span>)<br>    docs_self = retriever_self_query.invoke(question_self)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n✅ 检索成功! 找到 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs_self)&#125;</span> 个文档。&quot;</span>)<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> docs_self:<br>        <span class="hljs-comment"># 打印出来验证一下是否真的过滤了</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;来源: <span class="hljs-subst">&#123;d.metadata.get(<span class="hljs-string">&#x27;source&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)&#125;</span> | 页码: <span class="hljs-subst">&#123;d.metadata.get(<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)&#125;</span>&quot;</span>)<br>        <br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n❌ 检索失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 调试技巧：如果你想看 LLM 到底生成了什么鬼东西导致解析失败</span><br>    <span class="hljs-comment"># 可以单独运行 query_constructor 看看</span><br>    <span class="hljs-comment"># debug_res = query_constructor.invoke(&#123;&quot;query&quot;: question_self&#125;)</span><br>    <span class="hljs-comment"># print(&quot;调试信息(LLM生成的结构化查询):&quot;, debug_res)</span><br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 1.4 自查询检索器 (显式构建版) ===
正在提问: 他们在第二讲中对Figure做了些什么？

✅ 检索成功! 找到 4 个文档。
来源: docs/matplotlib/第二回：艺术画笔见乾坤.pdf | 页码: 9
来源: docs/matplotlib/第二回：艺术画笔见乾坤.pdf | 页码: 8
来源: docs/matplotlib/第二回：艺术画笔见乾坤.pdf | 页码: 10
来源: docs/matplotlib/第二回：艺术画笔见乾坤.pdf | 页码: 1
</code></pre>
<p>1.5 其他技巧：压缩 (Contextual Compression)<br>使用本地 LLM 对检索回来的长文档进行“瘦身”，只保留相关句子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [v0.3 变化] 导入路径调整</span><br><span class="hljs-keyword">from</span> langchain.retrievers <span class="hljs-keyword">import</span> ContextualCompressionRetriever<br><span class="hljs-keyword">from</span> langchain.retrievers.document_compressors <span class="hljs-keyword">import</span> LLMChainExtractor<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 1.5 上下文压缩检索 ===&quot;</span>)<br><br><span class="hljs-comment"># 1. 创建压缩器</span><br><span class="hljs-comment"># LLMChainExtractor: 一个专门的链，它会把文档扔给 LLM，让 LLM 提取与问题相关的部分</span><br>compressor = LLMChainExtractor.from_llm(llm_model)<br><br><span class="hljs-comment"># 2. 创建压缩检索器</span><br><span class="hljs-comment"># base_retriever: 基础检索器 (Chroma)，负责先捞出一大堆文档</span><br><span class="hljs-comment"># base_compressor: 压缩器，负责把捞出来的文档进行精简</span><br>compression_retriever = ContextualCompressionRetriever(<br>    base_compressor=compressor,<br>    base_retriever=vectordb_matplotlib.as_retriever()<br>)<br><br>question_compress = <span class="hljs-string">&quot;Matplotlib是什么？&quot;</span><br><br><span class="hljs-comment"># 执行检索</span><br><span class="hljs-comment"># 过程：Chroma 检索 -&gt; 返回文档 -&gt; Qwen 阅读并提取关键句 -&gt; 返回最终结果</span><br>compressed_docs = compression_retriever.invoke(question_compress)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pretty_print_docs</span>(<span class="hljs-params">docs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n<span class="hljs-subst">&#123;<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>&#125;</span>\n&quot;</span>.join([<span class="hljs-string">f&quot;Document <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>:\n&quot;</span> + d.page_content <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(docs)]))<br><br>pretty_print_docs(compressed_docs)<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 1.5 上下文压缩检索 ===
Document 1:
Matplotlib 是一个 Python 2D 绘图库，能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形，用来绘制各种静态，动态，交互式的图表。Matplotlib 可用于 Python 脚本， Python 和 IPython Shell 、 Jupyter notebook ， Web 应用程序服务器和各种图形用户界面工具包等。Matplotlib 是 Python 数据可视化库中的泰斗，它已经成为 python 中公认的数据可视化工具，我们所熟知的 pandas 和 seaborn 的绘图接口其实也是基于 matplotlib 所作的高级封装。
--------------------------------------------------
Document 2:
Matplotlib 是一个 Python 2D 绘图库，能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形，用来绘制各种静态，动态，交互式的图表。Matplotlib 可用于 Python 脚本， Python 和 IPython Shell 、 Jupyter notebook ， Web 应用程序服务器和各种图形用户界面工具包等。Matplotlib 是 Python 数据可视化库中的泰斗，它已经成为 python 中公认的数据可视化工具，我们所熟知的 pandas 和 seaborn 的绘图接口其实也是基于 matplotlib 所作的高级封装。
--------------------------------------------------
Document 3:
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D   
from matplotlib.patches import Circle, Wedge
from matplotlib.collections import PatchCollection
--------------------------------------------------
Document 4:
matplotlib 宇宙的核⼼，容纳了⼤量元素⽤来构造⼀幅幅⼦图，⼀个 figure 可以由⼀个或多个⼦图组成
</code></pre>
<p>结合 MMR 和 压缩：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 结合 MMR 和 压缩 ===&quot;</span>)<br><br><span class="hljs-comment"># 我们可以把 base_retriever 设置为 MMR 模式</span><br>compression_retriever_mmr = ContextualCompressionRetriever(<br>    base_compressor=compressor,<br>    base_retriever=vectordb_matplotlib.as_retriever(search_type=<span class="hljs-string">&quot;mmr&quot;</span>)<br>)<br><br>compressed_docs_mmr = compression_retriever_mmr.invoke(question_compress)<br>pretty_print_docs(compressed_docs_mmr)<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 结合 MMR 和 压缩 ===
Document 1:
Matplotlib 是一个 Python 2D 绘图库，能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形，用来绘制各种静态，动态，交互式的图表。Matplotlib 可用于 Python 脚本， Python 和 IPython Shell 、 Jupyter notebook ， Web 应用程序服务器和各种图形用户界面工具包等。Matplotlib 是 Python 数据可视化库中的泰斗，它已经成为 python 中公认的数据可视化工具，我们所熟知的 pandas 和 seaborn 的绘图接口其实也是基于 matplotlib 所作的高级封装。
--------------------------------------------------
Document 2:
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D   
from matplotlib.patches import Circle, Wedge
from matplotlib.collections import PatchCollection
</code></pre>
<p>ContextualCompressionRetriever: 这是一个管道（Pipeline）。如果基础检索器返回了 1000 字的文档，但其中只有 50 字是回答问题的，压缩器就会把这 50 字提取出来，扔掉剩下的 950 字。这能显著提高最终问答的准确率。</p>
<ol start="3">
<li>其他类型的检索 (SVM &amp; TF-IDF)<br>LangChain v0.3 中，SVM 和 TF-IDF 检索器位于 langchain_community。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># [v0.3 变化] 导入路径调整</span><br><span class="hljs-keyword">from</span> langchain_community.retrievers <span class="hljs-keyword">import</span> SVMRetriever, TFIDFRetriever<br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> PyPDFLoader<br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 3. 其他类型检索 (SVM &amp; TF-IDF) ===&quot;</span>)<br><br><span class="hljs-comment"># 1. 加载并切分数据 (重新加载一遍第一回作为测试)</span><br>loader = PyPDFLoader(<span class="hljs-string">&quot;docs/matplotlib/第一回：Matplotlib初相识.pdf&quot;</span>)<br>docs = loader.load()<br>text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">1500</span>, chunk_overlap=<span class="hljs-number">150</span>)<br>splits = text_splitter.split_documents(docs)<br><br><span class="hljs-comment"># 2. 创建检索器</span><br><span class="hljs-comment"># SVMRetriever: 使用支持向量机算法进行检索 (依赖 Embedding)</span><br>svm_retriever = SVMRetriever.from_documents(splits, embedding_model)<br><br><span class="hljs-comment"># TFIDFRetriever: 使用词频-逆文档频率统计进行检索 (纯统计，不需要 Embedding 模型)</span><br>tfidf_retriever = TFIDFRetriever.from_documents(splits)<br><br>question_other = <span class="hljs-string">&quot;Matplotlib是什么？&quot;</span><br><br><span class="hljs-comment"># 3. 测试 SVM</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- SVM 检索结果 ---&quot;</span>)<br>docs_svm = svm_retriever.invoke(question_other)<br><span class="hljs-keyword">if</span> docs_svm:<br>    <span class="hljs-built_in">print</span>(docs_svm[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">100</span>])<br><br><span class="hljs-comment"># 4. 测试 TF-IDF</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- TF-IDF 检索结果 ---&quot;</span>)<br>docs_tfidf = tfidf_retriever.invoke(question_other)<br><span class="hljs-keyword">if</span> docs_tfidf:<br>    <span class="hljs-built_in">print</span>(docs_tfidf[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">100</span>])<br></code></pre></td></tr></table></figure>


<pre><code class="hljs">=== 3. 其他类型检索 (SVM &amp; TF-IDF) ===
--- SVM 检索结果 ---
第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个 Python 2D 绘图库，能够以多种硬拷⻉格式和跨平台的交互式环境⽣成出版物质量的图形，⽤来绘制

--- TF-IDF 检索结果 ---
By Datawhale 数据可视化开源⼩组
© Copyright © Copyright 2021.
x = np.linspace(0, 2, 100)
plt.plot(x, x, label
</code></pre>
<h2 id="第六章-问答-Question-Answering"><a href="#第六章-问答-Question-Answering" class="headerlink" title="第六章 问答 Question Answering"></a>第六章 问答 Question Answering</h2><p>一、加载向量数据库<br>二、构造检索式问答链<br>三、深入探究检索式问答链<br>四、实验：状态记录<br>本节：拿到检索到的问答和问题一起传递给大语言模型，获得答案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引入 本地索引模型和大模型</span><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;/home/py/shared/StudyChatgpt&#x27;</span>)<br><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_embedding_model, get_chat_model2<br><br><span class="hljs-comment"># 获取本地模型实例</span><br>embedding_model = get_embedding_model()<br>llm_model = get_chat_model2() <span class="hljs-comment"># Qwen2.5-7B</span><br></code></pre></td></tr></table></figure>

<pre><code class="hljs">🚀 正在从本地缓存加载模型: BAAI/bge-base-zh-v1.5 ...
✅ 模型加载成功！
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;========= 一、加载向量数据库 (VectorStore) ===========&quot;</span>)<br><span class="hljs-comment"># [v0.3 变化] Chroma 移到了 langchain_chroma 包</span><br><span class="hljs-keyword">from</span> langchain_chroma <span class="hljs-keyword">import</span> Chroma<br><br><span class="hljs-comment"># 1. 定义持久化目录 (和你之前保存的路径一致)</span><br>persist_directory = <span class="hljs-string">&#x27;docs/chroma/matplotlib/&#x27;</span><br><br><span class="hljs-comment"># 2. 加载向量数据库</span><br><span class="hljs-comment"># 含义：从磁盘读取数据库，并指定使用本地 Embedding 模型进行向量计算</span><br>vectordb = Chroma(<br>    persist_directory=persist_directory,<br>    embedding_function=embedding_model<br>)<br><br><span class="hljs-comment"># 3. 检查数据库容量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据库中文档数量: <span class="hljs-subst">&#123;vectordb._collection.count()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 4. 测试检索</span><br>question = <span class="hljs-string">&quot;这节课的主要话题是什么&quot;</span><br><span class="hljs-comment"># similarity_search: 计算余弦相似度，找最相似的 3 个片段</span><br>docs = vectordb.similarity_search(question, k=<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;检索到的文档数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第一个文档片段: <span class="hljs-subst">&#123;docs[<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">50</span>]&#125;</span>...&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">========= 一、加载向量数据库 (VectorStore) ===========
数据库中文档数量: 27
检索到的文档数: 3
第一个文档片段: By Datawhale 数据可视化开源⼩组
© Copyright © Copyright 202...
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 二、构造检索式问答链 ======&quot;</span>)<br><span class="hljs-comment"># 构建标准问答链（Stuff模式：把所有文档一次性塞给 LLM）</span><br><span class="hljs-comment"># [v0.3 变化] 引入构建链的工厂函数</span><br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> create_retrieval_chain<br><span class="hljs-keyword">from</span> langchain.chains.combine_documents <span class="hljs-keyword">import</span> create_stuff_documents_chain<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br><span class="hljs-comment"># 1. 创建 Prompt (提示词模板)</span><br><span class="hljs-comment"># 含义：定义 LLM 的角色。&#123;context&#125; 是检索到的文档，&#123;input&#125; 是用户问题。</span><br>system_prompt = (<br>    <span class="hljs-string">&quot;你是一个助教。使用以下检索到的上下文来回答问题。&quot;</span><br>    <span class="hljs-string">&quot;如果你不知道答案，就说不知道。答案最多使用三个句子。&quot;</span><br>    <span class="hljs-string">&quot;\n\n&quot;</span><br>    <span class="hljs-string">&quot;&#123;context&#125;&quot;</span><br>)<br><br>prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, system_prompt),<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;input&#125;&quot;</span>),<br>])<br><br><span class="hljs-comment"># 2. 创建文档处理链 (Stuff Documents Chain)</span><br><span class="hljs-comment"># 含义：这个链负责把检索到的 docs 填充进上面的 prompt 里的 &#123;context&#125;，然后传给 LLM</span><br><span class="hljs-comment"># create_stuff_documents_chain: 创建一个“填充”链。它只是把文档拼起来塞给 LLM，不负责检索。</span><br>question_answer_chain = create_stuff_documents_chain(llm_model, prompt)<br><br><span class="hljs-comment"># 3. 创建最终的检索问答链 (Retrieval Chain)</span><br><span class="hljs-comment"># 含义：这个链负责协调：拿问题 -&gt; 找文档(retriever) -&gt; 塞文档(question_answer_chain) -&gt; 得到答案</span><br><span class="hljs-comment"># vectordb 是一个向量数据库对象   -》     通用的检索器接口（Retriever）【只需要给他问题，他最后会给你答案】</span><br><span class="hljs-comment"># vectordb.as_retriever(): 把向量库变成检索器接口</span><br><span class="hljs-comment"># create_retrieval_chain: 创建一个“RAG”链。它负责调用检索器获取文档，然后调用上面的填充链。</span><br>rag_chain = create_retrieval_chain(vectordb.as_retriever(), question_answer_chain)<br><br><span class="hljs-comment"># 4. 运行</span><br><span class="hljs-comment"># [v0.3 变化] 使用 .invoke 而不是 .run 或 __call__</span><br>question = <span class="hljs-string">&quot;这节课的主要话题是什么&quot;</span><br><span class="hljs-comment"># 返回的是一个字典，包含 &#x27;input&#x27;, &#x27;context&#x27;, &#x27;answer&#x27;</span><br>result = rag_chain.invoke(&#123;<span class="hljs-string">&quot;input&quot;</span>: question&#125;)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 普通检索问答结果 ===&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-string">&quot;answer&quot;</span>])<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 二、构造检索式问答链 ======

=== 普通检索问答结果 ===
这节课主要介绍了matplotlib的基本概念和使用方法，包括Artist对象的分类（primitives和containers）、绘图区和渲染器的基础逻辑，以及如何在matplotlib中进行数据可视化，如绘制折线图和柱状图等。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 三、深入探究：处理长文档(MapReduce / Refine) ===&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 3.1 基于模板的检索式问答链 (Custom Prompt) ===&quot;</span>)<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br><span class="hljs-comment"># 1. 定义 Prompt</span><br>template = <span class="hljs-string">&quot;&quot;&quot;使用以下上下文片段来回答最后的问题。如果你不知道答案，只需说不知道，不要试图编造答案。答案最多使用三个句子。尽量简明扼要地回答。在回答的最后一定要说&quot;感谢您的提问！&quot;</span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string">问题：&#123;question&#125;</span><br><span class="hljs-string">有用的回答：&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 第二部分：制作“模具” (PromptTemplate) langchain能够理解的对象，可以自动对照填入用户输入的context和query</span><br><span class="hljs-comment"># 变量识别：LangChain 需要自动识别出 &#123;context&#125; 和 &#123;question&#125; 是变量，而不是普通文本。from_template 会自动解析这些花括号。</span><br><span class="hljs-comment"># 格式化能力：当链运行时，它需要调用 .format() 方法把文档和问题填进去。纯字符串没有这个功能，只有 PromptTemplate 对象才有。</span><br><span class="hljs-comment"># 接口规范：下面的 RetrievalQA 链只接受 PromptTemplate 对象，不接受纯字符串。</span><br>QA_CHAIN_PROMPT = PromptTemplate.from_template(template)<br><br><span class="hljs-comment"># 2. 构建链 (使用兼容接口)</span><br><span class="hljs-comment"># [注意] 虽然是 v0.3，但在处理非 Stuff 模式或为了兼容旧逻辑时，RetrievalQA 依然可用</span><br>qa_chain = RetrievalQA.from_chain_type(<br>    llm_model,<br>    retriever=vectordb.as_retriever(), <span class="hljs-comment"># 检索器接口 负责去向量库找资料</span><br>    chain_type=<span class="hljs-string">&quot;stuff&quot;</span>, <span class="hljs-comment"># 策略：&quot;Stuff&quot;意味着把找到的所有资料一股脑塞进 Prompt 里</span><br>    return_source_documents=<span class="hljs-literal">True</span>,<span class="hljs-comment"># 开启调试：告诉我在哪找到的答案</span><br>    chain_type_kwargs=&#123;<span class="hljs-string">&quot;prompt&quot;</span>: QA_CHAIN_PROMPT&#125; <span class="hljs-comment"># 注入：把我们的自定义模具装进去！</span><br>)<br><br><span class="hljs-comment"># 3. 运行</span><br>question = <span class="hljs-string">&quot;这门课会学习 Python 吗&quot;</span><br><span class="hljs-comment"># invoke 参数键通常是 &#x27;query&#x27; 或 &#x27;input&#x27;</span><br>result = qa_chain.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: question&#125;)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 自定义 Prompt 结果 ===&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-string">&quot;result&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;参考文档: <span class="hljs-subst">&#123;result[<span class="hljs-string">&#x27;source_documents&#x27;</span>][<span class="hljs-number">0</span>].page_content[:<span class="hljs-number">50</span>]&#125;</span>...&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 三、深入探究：处理长文档(MapReduce / Refine) ===
====== 3.1 基于模板的检索式问答链 (Custom Prompt) ===

=== 自定义 Prompt 结果 ===
这门课主要学习使用 Matplotlib 库进行数据可视化，但不会直接教授 Python 语言的基础知识。感谢您的提问！
参考文档: 第⼀回： Matplotlib 初相识
⼀、认识 matplotlib
Matplotlib 是⼀个...
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 3.2 基于 MapReduce 的检索式问答链 ===&quot;</span>)<br><span class="hljs-comment"># MapReduce 适合处理大量文档，它会先让 LLM 分别阅读每个文档，最后再汇总。</span><br><span class="hljs-comment"># 1. 构建 MapReduce 链</span><br><span class="hljs-comment"># 含义：chain_type=&quot;map_reduce&quot; 告诉 LangChain 使用分治策略</span><br>qa_chain_mr = RetrievalQA.from_chain_type(<br>    llm_model,<br>    retriever=vectordb.as_retriever(),<br>    chain_type=<span class="hljs-string">&quot;map_reduce&quot;</span>  <span class="hljs-comment"># 策略：&quot;map_reduce&quot;</span><br>                            <span class="hljs-comment"># 先把找到的 3 个文档片段，分别发给 LLM 3 次，让 LLM 针对每个片段单独提取答案（“这段里有没有提到 Python？”）。</span><br>                            <span class="hljs-comment"># Reduce (合)：把这 3 次提取出的“中间结果”汇总在一起，再发给 LLM 一次，生成最终答案。</span><br>)<br><br><span class="hljs-comment"># 我这里有一个疑问 为什么上面使用stuff策略，需要使用自定义模板。而这里使用mapreduce策略，使用langchain默认的模板</span><br><span class="hljs-comment"># 因为stuff模式 是一股脑的把所有文档塞给LLM，只需要一步，只需要一个模板，使用自定义可以写的更准确</span><br><span class="hljs-comment"># 而mapreduce模式是分片塞给LLM，所以如果要自定义，需要定义两个不同的prompt模板用于map和reduce阶段</span><br>        <span class="hljs-comment"># Question Prompt (Map阶段)：用于询问每个单独的片段。“请在这个片段里找找有没有关于 Python 的信息，如果没有就忽略。”</span><br>        <span class="hljs-comment"># Combine Prompt (Reduce阶段)：用于汇总。“这里有几段关于 Python 的摘要，请把它们整合成一个通顺的最终回答。”</span><br><br><span class="hljs-comment"># 2. 运行</span><br>question = <span class="hljs-string">&quot;这门课会学习 Python 吗&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== MapReduce 处理中 (速度较慢) ===&quot;</span>)<br>result_mr = qa_chain_mr.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: question&#125;)<br><br><span class="hljs-built_in">print</span>(result_mr[<span class="hljs-string">&quot;result&quot;</span>])<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 3.2 基于 MapReduce 的检索式问答链 ===

=== MapReduce 处理中 (速度较慢) ===
根据提供的文本内容，没有直接提到这门课是否会学习 Python。文本主要介绍了 Matplotlib 库的基本概念和使用方法，但没有明确说明课程是否涵盖 Python 语言的学习。因此，我不确定这门课是否会学习 Python。
</code></pre>
<p>LangChain 并不是通过分析你提的问题内容（比如是问天气还是问代码）来决定用什么 Prompt 的。<br>它的判断逻辑非常简单粗暴：完全基于你传入的 chain_type 参数。<br>这就像去餐厅点餐：<br>你点了 “stuff” 套餐，厨房就拿出一张固定的 A 只有一张食谱（Stuff Prompt）。<br>你点了 “map_reduce” 套餐，厨房就拿出一套固定的 B 食谱（Map Prompt + Reduce Prompt）。<br>它不管你是谁，也不管你要吃什么（问什么问题），只要套餐名确定了，它就用预先写死在代码里的默认模板。</p>
<ol>
<li>它是怎么“查表”的？<br>当你调用 RetrievalQA.from_chain_type(…, chain_type&#x3D;”stuff”) 时，LangChain 内部实际上运行了一个类似“工厂模式”的分发器（Loader）。<br>虽然真实源代码很复杂，但逻辑简化下来就是这样：<br>Python</li>
</ol>
<h1 id="伪代码：LangChain-内部的-load-qa-chain-函数逻辑"><a href="#伪代码：LangChain-内部的-load-qa-chain-函数逻辑" class="headerlink" title="伪代码：LangChain 内部的 load_qa_chain 函数逻辑"></a>伪代码：LangChain 内部的 load_qa_chain 函数逻辑</h1><p>def load_qa_chain(llm, chain_type&#x3D;”stuff”, **kwargs):</p>
<pre><code class="hljs">if chain_type == &quot;stuff&quot;:
    # 1. 导入写死的 Stuff 英文模板
    from langchain.prompts import DEFAULT_STUFF_PROMPT
    # 2. 如果用户没传 prompt，就用这个默认的
    final_prompt = kwargs.get(&quot;prompt&quot;, DEFAULT_STUFF_PROMPT)
    return StuffDocumentsChain(llm, prompt=final_prompt)

elif chain_type == &quot;map_reduce&quot;:
    # 1. 导入写死的 MapReduce 英文模板
    from langchain.prompts import DEFAULT_MAP_PROMPT, DEFAULT_COMBINE_PROMPT
    # 2. 如果用户没传，就用默认的
    map_prompt = kwargs.get(&quot;question_prompt&quot;, DEFAULT_MAP_PROMPT)
    combine_prompt = kwargs.get(&quot;combine_prompt&quot;, DEFAULT_COMBINE_PROMPT)
    return MapReduceDocumentsChain(llm, map_prompt=map_prompt, combine_prompt=combine_prompt)

# ... 其他类型 (refine, map_rerank)
</code></pre>
<p>结论： 它是一一对应的**硬编码（Hardcoded）**关系。</p>
<ol start="2">
<li>这些“默认 Prompt”长什么样？<br>因为 LangChain 是外国人写的，所以这些默认 Prompt 全是英文。这也是为什么如果你不自定义，AI 经常会用英文回答你的中文问题。<br>我们可以把它们“打印”出来看看：<br>Stuff 模式的默认 Prompt<br>实际上就是一段通用的英文指令：<br>“Use the following pieces of context to answer the question at the end. If you don’t know the answer, just say that you don’t know, don’t try to make up an answer. {context} Question: {question} Helpful Answer:”</li>
</ol>
<p>MapReduce 模式的默认 Prompt<br>它更复杂，包含两部分：<br>Question Prompt (Map阶段):<br>“Use the following portion of a long document to see if any of the text is relevant to answer the question. Return any relevant text verbatim.” (大致意思：看看这段话跟问题沾不沾边，沾边就摘抄下来)</p>
<p>Combine Prompt (Reduce阶段):<br>“Given the following extracted parts of a long document and a question, create a final answer.” (大致意思：根据上面摘抄的这些片段，给我写个总结答案)</p>
<ol start="3">
<li>如何自己查看默认 Prompt？<br>你不需要猜，可以在代码里直接把 LangChain 帮你选的 Prompt 打印出来看一眼：</li>
</ol>
<p>Python</p>
<p>构建链（不传入自定义 Prompt，让它用默认的）</p>
<p>qa &#x3D; RetrievalQA.from_chain_type(llm, chain_type&#x3D;”stuff”, retriever&#x3D;retriever)</p>
<p>打印看看它到底用了什么模板</p>
<p>注意：不同版本路径可能略有不同，但通常藏在 combine_documents_chain 里</p>
<p>print(qa.combine_documents_chain.llm_chain.prompt.template)<br>总结<br>LangChain **“不知道”**你需要什么样的 Prompt，它只是机械地执行命令：</p>
<p>你选 stuff -&gt; 它加载 Default Stuff Prompt (英文)。</p>
<p>你选 map_reduce -&gt; 它加载 Default Map+Reduce Prompts (英文)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 3.3 基于 Refine 的检索式问答链 ===&quot;</span>)<br><span class="hljs-comment"># 1. 构建 Refine 链</span><br>qa_chain_refine = RetrievalQA.from_chain_type(<br>    llm_model,<br>    retriever=vectordb.as_retriever(),<br>    chain_type=<span class="hljs-string">&quot;refine&quot;</span>  <span class="hljs-comment"># refine（优化/精炼）策略，用一个形象的比喻就是 滚雪球   带着上一步的结果迭代优化</span><br>)<br><br><span class="hljs-comment"># 2. 运行</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== Refine 处理中 (串行处理，较慢) ===&quot;</span>)<br>result_refine = qa_chain_refine.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: question&#125;)<br><br><span class="hljs-built_in">print</span>(result_refine[<span class="hljs-string">&quot;result&quot;</span>])<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 3.3 基于 Refine 的检索式问答链 ===

=== Refine 处理中 (串行处理，较慢) ===
好的，根据提供的新上下文，我们将对原有的回答进行适当的补充和调整，以更好地涵盖 Python 和 Matplotlib 的相关内容。

---

### 一、认识 Matplotlib
Matplotlib 是一个 Python 2D 绘图库，能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形，用于绘制各种静态、动态和交互式的图表。Matplotlib 可用于 Python 脚本、Python 和 IPython Shell、Jupyter notebook、Web 应用程序服务器和各种图形用户界面工具包等。

Matplotlib 是 Python 数据可视化库中的重要工具，它已经成为 Python 中公认的数据可视化工具。我们所熟知的 pandas 和 seaborn 的绘图接口其实也是基于 Matplotlib 所作的高级封装。

为了对 Matplotlib 有更好的理解，让我们从一些最基本的概念开始认识它，再逐渐过渡到一些高级技巧中。

### 二、一个最简单的绘图例子
Matplotlib 的图像是画在 figure（如窗口、Jupyter 窗体）上的，每个 figure 又包含了一个或多个 axes（一个可以指定坐标系的子区域）。最简单的创建 figure 以及 axes 的方式是通过 `pyplot.subplots` 命令，创建 axes 以后，可以使用 `Axes.plot` 绘制最简易的折线图。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<br>plt.plot(x, x, label=<span class="hljs-string">&#x27;linear&#x27;</span>)<br>plt.plot(x, x**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;quadratic&#x27;</span>)<br>plt.plot(x, x**<span class="hljs-number">3</span>, label=<span class="hljs-string">&#x27;cubic&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x label&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y label&#x27;</span>)<br>plt.title(<span class="hljs-string">&quot;Simple Plot&quot;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>

#### 技巧：在 Jupyter Notebook 中使用 Matplotlib
在 Jupyter Notebook 中使用 Matplotlib 时，代码运行后会自动打印出类似 `&lt;matplotlib.lines.Line2D at 0x23155916dc0&gt;` 这样的信息，这是因为 Matplotlib 的绘图代码默认打印出最后一个对象。如果不想显示这句话，有以下三种方法：

1. 在代码块最后加一个分号 `;`。
2. 在代码块最后加一句 `plt.show()`。
3. 在绘图时将绘图对象显式赋值给一个变量，如将 `plt.plot([1, 2, 3, 4])` 改成 `line = plt.plot([1, 2, 3, 4])`。

#### 更简单的绘图方式
和 MATLAB 命令类似，你还可以通过一种更简单的方式绘制图像。`matplotlib.pyplot` 方法能够直接在当前 axes 上绘制图像，如果用户未指定 axes，Matplotlib 会帮你自动创建一个。所以上面的例子也可以简化为以下这行代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, x, label=<span class="hljs-string">&#x27;linear&#x27;</span>)<br>plt.plot(x, x**<span class="hljs-number">2</span>, label=<span class="hljs-string">&#x27;quadratic&#x27;</span>)<br>plt.plot(x, x**<span class="hljs-number">3</span>, label=<span class="hljs-string">&#x27;cubic&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x label&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y label&#x27;</span>)<br>plt.title(<span class="hljs-string">&quot;Simple Plot&quot;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>

### 三、通⽤绘图模板
由于 Matplotlib 的知识点非常繁杂，在实际使用过程中也不可能将全部 API 都记住，很多时候都是边用边查。因此这里提供一个通用的绘图基础模板，任何复杂的图表几乎都可以基于这个模板骨架填充内容而成。初学者刚开始学习时只需要牢记这个模板就足以应对大部分简单图表的绘制，在学习过程中可以将这个模板模块化，了解每个模块在做什么，在绘制复杂图表时如何修改，填充对应的模块。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># step1 准备数据</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<br>y = x**<span class="hljs-number">2</span><br><br><span class="hljs-comment"># step2 设置绘图样式，这一步的扩展参考第五章进一步学习，这一步不是必须的，样式也可以在绘制图像是进行设置</span><br>mpl.rc(<span class="hljs-string">&#x27;lines&#x27;</span>, linewidth=<span class="hljs-number">4</span>, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>)<br><br><span class="hljs-comment"># step3 定义布局，这一步的扩展参考第三章进一步学习</span><br>fig, ax = plt.subplots()<br><br><span class="hljs-comment"># step4 绘制图像，这一步的扩展参考第二章进一步学习</span><br>ax.plot(x, y, label=<span class="hljs-string">&#x27;quadratic&#x27;</span>)<br><br><span class="hljs-comment"># step5 添加标签、文字和图例，这一步的扩展参考第四章进一步学习</span><br>ax.set_xlabel(<span class="hljs-string">&#x27;x label&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;y label&#x27;</span>)<br>ax.set_title(<span class="hljs-string">&quot;Simple Plot&quot;</span>)<br>ax.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>

### 思考题
请思考两种绘图模式的优缺点和各自适合的使用场景。

#### OO 模式
- **优点**：
  - 更加面向对象，代码结构清晰，易于维护。
  - 可以更好地控制绘图的各个方面，灵活性高。
- **缺点**：
  - 代码相对复杂，初学者可能需要更多时间来理解。
  - 对于简单的绘图任务，代码量可能较多。

#### pyplot 模式
- **优点**：
  - 代码简洁，易于上手，适合快速绘制简单的图表。
  - 适合初学者和快速原型设计。
- **缺点**：
  - 代码结构不够清晰，难以维护。
  - 对于复杂的绘图任务，代码可能不够灵活。

### pyplot 绘图模式的简单模板
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># step1 准备数据</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<br>y = x**<span class="hljs-number">2</span><br><br><span class="hljs-comment"># step2 设置绘图样式，这一步的扩展参考第五章进一步学习，这一步不是必须的，样式也可以在绘制图像是进行设置</span><br>mpl.rc(<span class="hljs-string">&#x27;lines&#x27;</span>, linewidth=<span class="hljs-number">4</span>, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>)<br><br><span class="hljs-comment"># step3 定义布局，这一步的扩展参考第三章进一步学习</span><br>fig, ax = plt.subplots()<br><br><span class="hljs-comment"># step4 绘制图像，这一步的扩展参考第二章进一步学习</span><br>plt.plot(x, y, label=<span class="hljs-string">&#x27;quadratic&#x27;</span>)<br><br><span class="hljs-comment"># step5 添加标签、文字和图例，这一步的扩展参考第四章进一步学习</span><br>plt.xlabel(<span class="hljs-string">&#x27;x label&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y label&#x27;</span>)<br>plt.title(<span class="hljs-string">&quot;Simple Plot&quot;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>

---

通过以上内容，我们不仅介绍了 Matplotlib 的基本使用方法，还详细讲解了 `Rectangle` 矩形类及其在直方图中的应用。这门课会涉及 Python 和 Matplotlib 的相关内容，帮助你更好地理解和使用 Matplotlib 进行数据可视化。
</code></pre>
<p>发现上面不同的策略，模型输出了不同的答案。。。。。。<br>上面的这个结果比 MapReduce 链的结果要好。这是因为使用 Refine 文档链通过累积上下文，使语言模型能渐进地完善答案，而不是孤立处理每个文档。这种策略可以有效解决信息分散带来的语义不完整问题。但是请注意，由于 LangChain 内部的限制，定义为 Refine 的问答链会默认返回英文作为答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====== 四、实验：状态记录 (Stateless Nature) ===&quot;</span>)<br><span class="hljs-comment"># llm chain 默认是没有记忆的</span><br><span class="hljs-comment"># 1. 构建一个新的简单链</span><br>qa_chain_no_memory = create_retrieval_chain(<br>    vectordb.as_retriever(),<br>    create_stuff_documents_chain(llm_model, prompt) <span class="hljs-comment"># 使用最开始定义的 prompt</span><br>)<br><br><span class="hljs-comment"># 2. 提问第一个问题</span><br>question1 = <span class="hljs-string">&quot;这门课会学习 Python 吗？&quot;</span><br>result1 = qa_chain_no_memory.invoke(&#123;<span class="hljs-string">&quot;input&quot;</span>: question1&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n问题1: <span class="hljs-subst">&#123;question1&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;回答1: <span class="hljs-subst">&#123;result1[<span class="hljs-string">&#x27;answer&#x27;</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 3. 提问第二个问题 (追问)</span><br><span class="hljs-comment"># 这里的 &quot;这一前提&quot; 指代上一个问题的答案，但 LLM 不知道     得到的答案与python无关</span><br>question2 = <span class="hljs-string">&quot;为什么需要这一前提&quot;</span> <br>result2 = qa_chain_no_memory.invoke(&#123;<span class="hljs-string">&quot;input&quot;</span>: question2&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n问题2: <span class="hljs-subst">&#123;question2&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;回答2: <span class="hljs-subst">&#123;result2[<span class="hljs-string">&#x27;answer&#x27;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">====== 四、实验：状态记录 (Stateless Nature) ===

问题1: 这门课会学习 Python 吗？
回答1: 这门课主要介绍 Matplotlib 库的使用，虽然会涉及一些 Python 代码来绘制图表，但主要 focus 在于 Matplotlib 的使用方法和技巧，而不是深入学习 Python 语言本身。所以严格来说，这门课不会系统地学习 Python。

问题2: 为什么需要这一前提
回答2: 您提到的“前提”不太明确。如果您是指为什么需要对象容器和绘图接口，那么可以解释如下：

对象容器和绘图接口的设计是为了提供灵活性和控制力，使得用户可以根据需要创建复杂的图表结构，并且能够精细地控制每个元素的属性。这种设计使得matplotlib成为一个强大且灵活的绘图库。
</code></pre>
<p>基本上，我们使用的链式（chain）没有任何状态的概念。它不记得之前的问题或之前的答案。为了实现这一点，我们需要引入内存，这是我们将在下一节中讨论的内容。create_history_aware_retriever 来处理历史对话</p>
<h2 id="第七章-聊天-Chat"><a href="#第七章-聊天-Chat" class="headerlink" title="第七章 聊天 Chat"></a>第七章 聊天 Chat</h2><p>一、复现之前代码<br>二、记忆（Memory）<br>三、对话检索链（ConversationalRetrievalChain）<br>四、定义一个适用于您文档的聊天机器人</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> shutil  <span class="hljs-comment"># 用于删除旧数据库文件夹</span><br><span class="hljs-keyword">import</span> panel <span class="hljs-keyword">as</span> pn<br><span class="hljs-keyword">import</span> param<br><br><span class="hljs-comment"># 1. 引入本地模型工具</span><br>sys.path.append(<span class="hljs-string">&#x27;/home/py/shared/StudyChatgpt&#x27;</span>)<br><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_embedding_model, get_chat_model2<br><br><span class="hljs-comment"># 2. 引入组件</span><br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> CSVLoader, PyPDFLoader, TextLoader<br><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><span class="hljs-keyword">from</span> langchain_chroma <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> ConversationalRetrievalChain<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferMemory<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br><span class="hljs-comment"># 初始化 Panel 扩展</span><br>pn.extension()<br><br><span class="hljs-comment"># ==========================================</span><br><span class="hljs-comment">#  【配置区】</span><br><span class="hljs-comment"># ==========================================</span><br><span class="hljs-comment"># 1. 固定文件路径（服务器本地文件）</span><br>FIXED_FILES = [<br>    <span class="hljs-string">&quot;docs/kenqiang/21.csv&quot;</span>, <br>    <span class="hljs-comment"># &quot;/home/py/data/manual.pdf&quot;</span><br>]<br><br><span class="hljs-comment"># 2. 向量数据库存储路径 (持久化目录)</span><br>DB_DIRECTORY = <span class="hljs-string">&quot;./chroma_db_store&quot;</span><br><span class="hljs-comment"># ==========================================</span><br><br><span class="hljs-comment"># --- 第一部分：通用文档加载器 ---</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_loader</span>(<span class="hljs-params">file_path</span>):<br>    ext = os.path.splitext(file_path)[<span class="hljs-number">1</span>].lower()<br>    <span class="hljs-keyword">if</span> ext == <span class="hljs-string">&#x27;.csv&#x27;</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> CSVLoader(file_path=file_path, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> CSVLoader(file_path=file_path, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> ext == <span class="hljs-string">&#x27;.pdf&#x27;</span>:<br>        <span class="hljs-keyword">return</span> PyPDFLoader(file_path)<br>    <span class="hljs-keyword">elif</span> ext == <span class="hljs-string">&#x27;.txt&#x27;</span>:<br>        <span class="hljs-keyword">return</span> TextLoader(file_path=file_path, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_qa_chain</span>(<span class="hljs-params">file_paths=<span class="hljs-literal">None</span>, k=<span class="hljs-number">4</span>, force_rebuild=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    [核心逻辑] 构建 RAG 链</span><br><span class="hljs-string">    :param file_paths: 文件路径列表</span><br><span class="hljs-string">    :param force_rebuild: 是否强制删除旧库重新构建</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    embeddings = get_embedding_model()<br>    llm = get_chat_model2() <br>    <br>    <span class="hljs-comment"># 检查本地是否已有数据库</span><br>    db_exists = os.path.exists(DB_DIRECTORY) <span class="hljs-keyword">and</span> os.path.isdir(DB_DIRECTORY)<br>    <br>    <span class="hljs-comment"># --- 分支 1: 加载已有数据库 (快速) ---</span><br>    <span class="hljs-keyword">if</span> db_exists <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> force_rebuild:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💎 检测到本地向量库 (<span class="hljs-subst">&#123;DB_DIRECTORY&#125;</span>)，直接加载...&quot;</span>)<br>        db = Chroma(persist_directory=DB_DIRECTORY, embedding_function=embeddings)<br>    <br>    <span class="hljs-comment"># --- 分支 2: 重新构建数据库 (慢速) ---</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;⚡️ 开始构建新知识库...&quot;</span>)<br>        <br>        <span class="hljs-comment"># 如果强制重建且库存在，先删除旧的</span><br>        <span class="hljs-keyword">if</span> db_exists <span class="hljs-keyword">and</span> force_rebuild:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;🧹 清理旧数据...&quot;</span>)<br>            shutil.rmtree(DB_DIRECTORY)<br>            <br>        all_documents = []<br>        <br>        <span class="hljs-comment"># 加载文件</span><br>        <span class="hljs-keyword">if</span> file_paths:<br>            <span class="hljs-keyword">for</span> file_path <span class="hljs-keyword">in</span> file_paths:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(file_path):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 文件不存在: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">try</span>:<br>                    loader = get_file_loader(file_path)<br>                    <span class="hljs-keyword">if</span> loader: all_documents.extend(loader.load())<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 加载失败 <span class="hljs-subst">&#123;file_path&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all_documents:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;没有加载到有效文档，无法构建知识库！&quot;</span>)<br><br>        text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">800</span>, chunk_overlap=<span class="hljs-number">100</span>)<br>        docs = text_splitter.split_documents(all_documents)<br>        <br>        <span class="hljs-comment"># 保存到磁盘 (persist_directory)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;💾 正在向量化 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(docs)&#125;</span> 个片段并保存到磁盘...&quot;</span>)<br>        db = Chroma.from_documents(docs, embeddings, persist_directory=DB_DIRECTORY)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;✅ 知识库构建完成！&quot;</span>)<br><br>    <span class="hljs-comment"># 构建检索器和链</span><br>    retriever = db.as_retriever(search_type=<span class="hljs-string">&quot;similarity&quot;</span>, search_kwargs=&#123;<span class="hljs-string">&quot;k&quot;</span>: k&#125;)<br>    <br>    template = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    你是一位专业的电商金牌客服，名字叫“小佳”。</span><br><span class="hljs-string">    请基于以下【背景知识】回答用户问题。如果不知道，请建议转人工。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    【背景知识】：</span><br><span class="hljs-string">    &#123;context&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    【聊天历史】：</span><br><span class="hljs-string">    &#123;chat_history&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    【用户问题】：</span><br><span class="hljs-string">    &#123;question&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    【你的回答】：</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    QA_PROMPT = PromptTemplate(input_variables=[<span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;chat_history&quot;</span>, <span class="hljs-string">&quot;question&quot;</span>], template=template)<br>    memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>, return_messages=<span class="hljs-literal">True</span>, output_key=<span class="hljs-string">&quot;answer&quot;</span>)<br>    <br>    qa = ConversationalRetrievalChain.from_llm(<br>        llm=llm, retriever=retriever, memory=memory,<br>        return_source_documents=<span class="hljs-literal">True</span>, return_generated_question=<span class="hljs-literal">True</span>,<br>        combine_docs_chain_kwargs=&#123;<span class="hljs-string">&quot;prompt&quot;</span>: QA_PROMPT&#125; <br>    )<br>    <span class="hljs-keyword">return</span> qa<br><br><span class="hljs-comment"># --- 第二部分：核心 GUI 逻辑类 ---</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatBotCore</span>(param.Parameterized):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, **params</span>):<br>        <span class="hljs-built_in">super</span>(ChatBotCore, <span class="hljs-variable language_">self</span>).__init__(**params)<br>        <span class="hljs-variable language_">self</span>.qa = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.panels = []<br>        <br>        <span class="hljs-comment"># [解决 NameError 的关键] </span><br>        <span class="hljs-comment"># 我们把 chat_box 定义为类的一个属性，自己管理自己</span><br>        <span class="hljs-variable language_">self</span>.chat_view = pn.Column(height=<span class="hljs-number">500</span>, scroll=<span class="hljs-literal">True</span>, css_classes=[<span class="hljs-string">&#x27;chat-box&#x27;</span>])<br>        <br>        <span class="hljs-comment"># 初始欢迎语</span><br>        welcome_msg = <span class="hljs-string">&quot;👋 亲~ 我是客服小佳。系统初始化中，请稍候...&quot;</span><br>        <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;👩‍💼 客服小佳:&#x27;</span>, welcome_msg, <span class="hljs-string">&#x27;sys&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 自动启动检查</span><br>        pn.state.onload(<span class="hljs-variable language_">self</span>.initial_check)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_message</span>(<span class="hljs-params">self, user, text, msg_type=<span class="hljs-string">&#x27;user&#x27;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;辅助函数：向聊天框添加消息&quot;&quot;&quot;</span><br>        styles = &#123;&#125;<br>        <span class="hljs-keyword">if</span> msg_type == <span class="hljs-string">&#x27;sys&#x27;</span>: <span class="hljs-comment"># 系统消息/客服</span><br>            styles = &#123;<span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;#fff0f6&#x27;</span>, <span class="hljs-string">&#x27;padding&#x27;</span>: <span class="hljs-string">&#x27;15px&#x27;</span>, <span class="hljs-string">&#x27;border-radius&#x27;</span>: <span class="hljs-string">&#x27;10px&#x27;</span>, <span class="hljs-string">&#x27;border&#x27;</span>: <span class="hljs-string">&#x27;1px solid #ffadd2&#x27;</span>, <span class="hljs-string">&#x27;overflow-wrap&#x27;</span>: <span class="hljs-string">&#x27;break-word&#x27;</span>, <span class="hljs-string">&#x27;word-break&#x27;</span>: <span class="hljs-string">&#x27;break-word&#x27;</span>&#125;<br>        <span class="hljs-keyword">elif</span> msg_type == <span class="hljs-string">&#x27;error&#x27;</span>:<br>            styles = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;padding&#x27;</span>: <span class="hljs-string">&#x27;10px&#x27;</span>&#125;<br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 用户</span><br>            styles = &#123;<span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;#f0f0f0&#x27;</span>, <span class="hljs-string">&#x27;padding&#x27;</span>: <span class="hljs-string">&#x27;10px&#x27;</span>, <span class="hljs-string">&#x27;border-radius&#x27;</span>: <span class="hljs-string">&#x27;8px&#x27;</span>&#125;<br>            <br>        <span class="hljs-variable language_">self</span>.panels.append(pn.Row(user, pn.pane.Markdown(text, width=<span class="hljs-number">600</span>, styles=styles)))<br>        <span class="hljs-variable language_">self</span>.chat_view.objects = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.panels)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_check</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;启动时检查：如果有库就直接加载，没有就提示&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> os.path.exists(DB_DIRECTORY):<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;⚙️ 系统:&#x27;</span>, <span class="hljs-string">&quot;检测到已有知识库，正在自动加载...&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-variable language_">self</span>.qa = create_qa_chain(force_rebuild=<span class="hljs-literal">False</span>)<br>                <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;✅ 系统:&#x27;</span>, <span class="hljs-string">&quot;知识库加载成功！您可以直接提问啦~&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;❌ 错误:&#x27;</span>, <span class="hljs-string">f&quot;加载旧库失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;⚠️ 系统:&#x27;</span>, <span class="hljs-string">&quot;未检测到知识库。请点击上方的【🛠️ 重建/更新知识库】按钮来初始化数据。&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rebuild_db_action</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;强制重建数据库（整合 上传文件 + 固定文件）&quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 1. 收集文件列表</span><br>        target_files = FIXED_FILES.copy()<br>        <br>        <span class="hljs-comment"># 2. 如果用户上传了临时文件</span><br>        <span class="hljs-keyword">if</span> file_input.value:<br>            save_path = <span class="hljs-string">f&quot;temp_<span class="hljs-subst">&#123;file_input.filename&#125;</span>&quot;</span><br>            file_input.save(save_path)<br>            target_files.append(save_path)<br>            <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> target_files:<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;⚠️ 提示:&#x27;</span>, <span class="hljs-string">&quot;没有找到任何文件配置（固定路径为空且未上传文件）&quot;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 3. 开始UI状态更新</span><br>        indicator.value = <span class="hljs-literal">True</span><br>        btn_rebuild.name = <span class="hljs-string">&quot;⏳ 构建中...&quot;</span><br>        btn_rebuild.disabled = <span class="hljs-literal">True</span><br>        <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;⚙️ 系统:&#x27;</span>, <span class="hljs-string">f&quot;正在读取 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(target_files)&#125;</span> 个文件并重新生成向量库，请稍候...&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br>        <br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 4. 强制重建 (force_rebuild=True)</span><br>            <span class="hljs-variable language_">self</span>.qa = create_qa_chain(file_paths=target_files, force_rebuild=<span class="hljs-literal">True</span>)<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;✅ 系统:&#x27;</span>, <span class="hljs-string">&quot;知识库更新完成！新数据已生效。&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;❌ 错误:&#x27;</span>, <span class="hljs-string">f&quot;构建失败: <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 5. 恢复UI</span><br>        indicator.value = <span class="hljs-literal">False</span><br>        btn_rebuild.name = <span class="hljs-string">&quot;🛠️ 重建/更新知识库&quot;</span><br>        btn_rebuild.disabled = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">chat_action</span>(<span class="hljs-params">self, query=<span class="hljs-literal">None</span></span>):<br>        user_text = query <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(query, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">else</span> text_input.value<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_text: <span class="hljs-keyword">return</span><br>        <br>        text_input.value = <span class="hljs-string">&quot;&quot;</span> <br>        <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;👤 贵宾:&#x27;</span>, user_text, <span class="hljs-string">&#x27;user&#x27;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.qa:<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;⚠️ 小佳:&#x27;</span>, <span class="hljs-string">&quot;亲，知识库还没准备好，请先点击【重建/更新知识库】哦~&quot;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># Loading 动画</span><br>        spinner = pn.indicators.LoadingSpinner(value=<span class="hljs-literal">True</span>, width=<span class="hljs-number">30</span>, height=<span class="hljs-number">30</span>, color=<span class="hljs-string">&#x27;primary&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.panels.append(pn.Row(<span class="hljs-string">&#x27;🤔 小佳思考中...&#x27;</span>, spinner))<br>        <span class="hljs-variable language_">self</span>.chat_view.objects = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.panels)<br>        <br>        <span class="hljs-keyword">try</span>:<br>            result = <span class="hljs-variable language_">self</span>.qa(&#123;<span class="hljs-string">&quot;question&quot;</span>: user_text&#125;)<br>            <span class="hljs-variable language_">self</span>.panels.pop() <span class="hljs-comment"># 移除 loading</span><br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;👩‍💼 客服小佳:&#x27;</span>, result[<span class="hljs-string">&#x27;answer&#x27;</span>], <span class="hljs-string">&#x27;sys&#x27;</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-variable language_">self</span>.panels.pop()<br>            <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;❌ 错误:&#x27;</span>, <span class="hljs-string">f&quot;系统出错了: <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_history</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-variable language_">self</span>.panels = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.qa: <span class="hljs-variable language_">self</span>.qa.memory.clear()<br>        <span class="hljs-variable language_">self</span>.chat_view.objects = []<br>        <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;👩‍💼 客服小佳:&#x27;</span>, <span class="hljs-string">&quot;记忆已清空，我们重新开始吧~ 😊&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer_to_human</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-variable language_">self</span>.add_message(<span class="hljs-string">&#x27;🎧 系统:&#x27;</span>, <span class="hljs-string">&quot;正在为您转接人工客服，请稍候...&quot;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_ask</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-variable language_">self</span>.chat_action(query=event.obj.name)<br><br><span class="hljs-comment"># --- 第三部分：构建 UI ---</span><br><br>cb = ChatBotCore()<br><br><span class="hljs-comment"># 1. 配置区 (保留了上传功能 + 数据库操作)</span><br>file_input = pn.widgets.FileInput(accept=<span class="hljs-string">&#x27;.pdf,.csv,.txt&#x27;</span>, height=<span class="hljs-number">40</span>)<br>btn_rebuild = pn.widgets.Button(name=<span class="hljs-string">&quot;🛠️ 重建/更新知识库&quot;</span>, button_type=<span class="hljs-string">&#x27;primary&#x27;</span>, width=<span class="hljs-number">150</span>)<br>btn_rebuild.on_click(cb.rebuild_db_action)<br>indicator = pn.indicators.LoadingSpinner(value=<span class="hljs-literal">False</span>, width=<span class="hljs-number">30</span>, height=<span class="hljs-number">30</span>, color=<span class="hljs-string">&#x27;primary&#x27;</span>)<br>btn_clear = pn.widgets.Button(name=<span class="hljs-string">&quot;🧹 清空对话&quot;</span>, button_type=<span class="hljs-string">&#x27;default&#x27;</span>, width=<span class="hljs-number">100</span>)<br>btn_clear.on_click(cb.clear_history)<br><br><span class="hljs-comment"># 提示说明</span><br>config_desc = pn.pane.Markdown(<span class="hljs-string">&quot;**配置:** 选择新文件(可选)并点击重建，将合并【上传文件】与【后台固定文件】生成新库。&quot;</span>, style=&#123;<span class="hljs-string">&#x27;font-size&#x27;</span>: <span class="hljs-string">&#x27;12px&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;#666&#x27;</span>&#125;)<br><br>config_row = pn.Column(<br>    pn.Row(file_input, btn_rebuild, indicator, btn_clear),<br>    config_desc<br>)<br><br><span class="hljs-comment"># 2. 聊天区 (直接从类中获取)</span><br><span class="hljs-comment"># 这一步解决了 &quot;chat_box is not defined&quot; 的问题，因为我们直接用 cb.chat_view</span><br>main_chat_layout = cb.chat_view <br><br><span class="hljs-comment"># 3. 快捷操作</span><br>btn_q1 = pn.widgets.Button(name=<span class="hljs-string">&quot;📦 怎么查快递？&quot;</span>, button_type=<span class="hljs-string">&#x27;light&#x27;</span>)<br>btn_q1.on_click(cb.quick_ask)<br>btn_human = pn.widgets.Button(name=<span class="hljs-string">&quot;🎧 转人工客服&quot;</span>, button_type=<span class="hljs-string">&#x27;danger&#x27;</span>, width=<span class="hljs-number">120</span>)<br>btn_human.on_click(cb.transfer_to_human)<br>suggestion_row = pn.Row(pn.pane.Markdown(<span class="hljs-string">&quot;**💡 快捷操作:**&quot;</span>), btn_q1, btn_human)<br><br><span class="hljs-comment"># 4. 输入区</span><br>text_input = pn.widgets.TextInput(placeholder=<span class="hljs-string">&#x27;请输入问题...&#x27;</span>, height=<span class="hljs-number">50</span>, sizing_mode=<span class="hljs-string">&#x27;stretch_width&#x27;</span>)<br>text_input.param.watch(<span class="hljs-keyword">lambda</span> event: cb.chat_action(), <span class="hljs-string">&#x27;value&#x27;</span>)<br>btn_send = pn.widgets.Button(name=<span class="hljs-string">&quot;发送 🚀&quot;</span>, button_type=<span class="hljs-string">&#x27;primary&#x27;</span>, width=<span class="hljs-number">80</span>, height=<span class="hljs-number">50</span>)<br>btn_send.on_click(<span class="hljs-keyword">lambda</span> event: cb.chat_action())<br>input_row = pn.Row(text_input, btn_send)<br><br><span class="hljs-comment"># 5. 最终布局</span><br>dashboard = pn.Column(<br>    pn.Row(pn.pane.Markdown(<span class="hljs-string">&#x27;# 🛍️ 客服小佳 (持久化记忆版)&#x27;</span>)),<br>    pn.layout.Divider(),<br>    config_row,<br>    pn.layout.Divider(),<br>    main_chat_layout,<br>    pn.layout.Divider(),<br>    suggestion_row,<br>    input_row,<br>    width=<span class="hljs-number">800</span><br>)<br><br>dashboard<br></code></pre></td></tr></table></figure>






<style>*[data-root-id],
*[data-root-id] > * {
  box-sizing: border-box;
  font-family: var(--jp-ui-font-family);
  font-size: var(--jp-ui-font-size1);
  color: var(--vscode-editor-foreground, var(--jp-ui-font-color1));
}

/* Override VSCode background color */
.cell-output-ipywidget-background:has(
    > .cell-output-ipywidget-background > .lm-Widget > *[data-root-id]
  ),
.cell-output-ipywidget-background:has(> .lm-Widget > *[data-root-id]) {
  background-color: transparent !important;
}
</style>



<div id="31941d73-ea23-45b9-818b-f18f702efbae">
  <div id="bebda29a-2479-421d-aa58-4cf32fc2ccb8" data-root-id="31941d73-ea23-45b9-818b-f18f702efbae" style="display: contents;"></div>
</div>
<script type="application/javascript">(function(root) {
  var docs_json = {"1050fed6-135f-4646-9253-b3f8077380ff":{"version":"3.2.2","title":"Bokeh Application","roots":[{"type":"object","name":"panel.models.browser.BrowserInfo","id":"31941d73-ea23-45b9-818b-f18f702efbae"},{"type":"object","name":"panel.models.comm_manager.CommManager","id":"eb3dd84b-9ff5-4def-b1c2-90964794d7cc","attributes":{"plot_id":"31941d73-ea23-45b9-818b-f18f702efbae","comm_id":"84f220e33a5e435b8ef46bdf61649069","client_comm_id":"7f50783d68864cc7acfda23f923ad49e"}}],"defs":[{"type":"model","name":"ReactiveHTML1"},{"type":"model","name":"FlexBox1","properties":[{"name":"align_content","kind":"Any","default":"flex-start"},{"name":"align_items","kind":"Any","default":"flex-start"},{"name":"flex_direction","kind":"Any","default":"row"},{"name":"flex_wrap","kind":"Any","default":"wrap"},{"name":"justify_content","kind":"Any","default":"flex-start"}]},{"type":"model","name":"FloatPanel1","properties":[{"name":"config","kind":"Any","default":{"type":"map"}},{"name":"contained","kind":"Any","default":true},{"name":"position","kind":"Any","default":"right-top"},{"name":"offsetx","kind":"Any","default":null},{"name":"offsety","kind":"Any","default":null},{"name":"theme","kind":"Any","default":"primary"},{"name":"status","kind":"Any","default":"normalized"}]},{"type":"model","name":"GridStack1","properties":[{"name":"mode","kind":"Any","default":"warn"},{"name":"ncols","kind":"Any","default":null},{"name":"nrows","kind":"Any","default":null},{"name":"allow_resize","kind":"Any","default":true},{"name":"allow_drag","kind":"Any","default":true},{"name":"state","kind":"Any","default":[]}]},{"type":"model","name":"drag1","properties":[{"name":"slider_width","kind":"Any","default":5},{"name":"slider_color","kind":"Any","default":"black"},{"name":"value","kind":"Any","default":50}]},{"type":"model","name":"click1","properties":[{"name":"terminal_output","kind":"Any","default":""},{"name":"debug_name","kind":"Any","default":""},{"name":"clears","kind":"Any","default":0}]},{"type":"model","name":"copy_to_clipboard1","properties":[{"name":"fill","kind":"Any","default":"none"},{"name":"value","kind":"Any","default":null}]},{"type":"model","name":"FastWrapper1","properties":[{"name":"object","kind":"Any","default":null},{"name":"style","kind":"Any","default":null}]},{"type":"model","name":"NotificationAreaBase1","properties":[{"name":"js_events","kind":"Any","default":{"type":"map"}},{"name":"position","kind":"Any","default":"bottom-right"},{"name":"_clear","kind":"Any","default":0}]},{"type":"model","name":"NotificationArea1","properties":[{"name":"js_events","kind":"Any","default":{"type":"map"}},{"name":"notifications","kind":"Any","default":[]},{"name":"position","kind":"Any","default":"bottom-right"},{"name":"_clear","kind":"Any","default":0},{"name":"types","kind":"Any","default":[{"type":"map","entries":[["type","warning"],["background","#ffc107"],["icon",{"type":"map","entries":[["className","fas fa-exclamation-triangle"],["tagName","i"],["color","white"]]}]]},{"type":"map","entries":[["type","info"],["background","#007bff"],["icon",{"type":"map","entries":[["className","fas fa-info-circle"],["tagName","i"],["color","white"]]}]]}]}]},{"type":"model","name":"Notification","properties":[{"name":"background","kind":"Any","default":null},{"name":"duration","kind":"Any","default":3000},{"name":"icon","kind":"Any","default":null},{"name":"message","kind":"Any","default":""},{"name":"notification_type","kind":"Any","default":null},{"name":"_destroyed","kind":"Any","default":false}]},{"type":"model","name":"TemplateActions1","properties":[{"name":"open_modal","kind":"Any","default":0},{"name":"close_modal","kind":"Any","default":0}]},{"type":"model","name":"BootstrapTemplateActions1","properties":[{"name":"open_modal","kind":"Any","default":0},{"name":"close_modal","kind":"Any","default":0}]},{"type":"model","name":"MaterialTemplateActions1","properties":[{"name":"open_modal","kind":"Any","default":0},{"name":"close_modal","kind":"Any","default":0}]}]}};
  var render_items = [{"docid":"1050fed6-135f-4646-9253-b3f8077380ff","roots":{"31941d73-ea23-45b9-818b-f18f702efbae":"bebda29a-2479-421d-aa58-4cf32fc2ccb8"},"root_ids":["31941d73-ea23-45b9-818b-f18f702efbae"]}];
  var docs = Object.values(docs_json)
  if (!docs) {
    return
  }
  const py_version = docs[0].version.replace('rc', '-rc.').replace('.dev', '-dev.')
  function embed_document(root) {
    var Bokeh = get_bokeh(root)
    Bokeh.embed.embed_items_notebook(docs_json, render_items);
    for (const render_item of render_items) {
      for (const root_id of render_item.root_ids) {
	const id_el = document.getElementById(root_id)
	if (id_el.children.length && (id_el.children[0].className === 'bk-root')) {
	  const root_el = id_el.children[0]
	  root_el.id = root_el.id + '-rendered'
	}
      }
    }
  }
  function get_bokeh(root) {
    if (root.Bokeh === undefined) {
      return null
    } else if (root.Bokeh.version !== py_version) {
      if (root.Bokeh.versions === undefined || !root.Bokeh.versions.has(py_version)) {
	return null
      }
      return root.Bokeh.versions.get(py_version);
    } else if (root.Bokeh.version === py_version) {
      return root.Bokeh
    }
    return null
  }
  function is_loaded(root) {
    var Bokeh = get_bokeh(root)
    return (Bokeh != null && Bokeh.Panel !== undefined)
  }
  if (is_loaded(root)) {
    embed_document(root);
  } else {
    var attempts = 0;
    var timer = setInterval(function(root) {
      if (is_loaded(root)) {
        clearInterval(timer);
        embed_document(root);
      } else if (document.readyState == "complete") {
        attempts++;
        if (attempts > 200) {
          clearInterval(timer);
	  var Bokeh = get_bokeh(root)
	  if (Bokeh == null || Bokeh.Panel == null) {
            console.warn("Panel: ERROR: Unable to run Panel code because Bokeh or Panel library is missing");
	  } else {
	    console.warn("Panel: WARNING: Attempting to render but not all required libraries could be resolved.")
	    embed_document(root)
	  }
        }
      }
    }, 25, root)
  }
})(window);</script>


<pre><code class="hljs">💎 检测到本地向量库 (./chroma_db_store)，直接加载...


/tmp/ipykernel_318522/1941869386.py:259: PanelDeprecationWarning: &#39;style&#39; is deprecated and will be removed in version 1.4, use &#39;styles&#39; instead.
  config_desc = pn.pane.Markdown(&quot;**配置:** 选择新文件(可选)并点击重建，将合并【上传文件】与【后台固定文件】生成新库。&quot;, style=&#123;&#39;font-size&#39;: &#39;12px&#39;, &#39;color&#39;: &#39;#666&#39;&#125;)

BokehModel(combine_events=True, render_bundle=&#123;&#39;docs_json&#39;: &#123;&#39;012d05a6-2c58-4deb-ad9b-5cea99868427&#39;: &#123;&#39;version…
</code></pre>
<p><img src="/.io//image-20251223230820491.png" srcset="/img/loading.gif" lazyload alt="image-20251223230820491"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/" class="category-chain-item">AI与技术</a>
  
  
    <span>></span>
    
  <a href="/categories/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C4%E4%BD%BF%E7%94%A8LangChain%E8%AE%BF%E9%97%AE%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE/" class="category-chain-item">吴恩达面向开发者的大模型手册4使用LangChain访问个人数据</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Prompt/" class="print-no-link">#Prompt</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>吴恩达面向开发者的大模型手册4使用LangChain访问个人数据</div>
      <div>https://py0909.github.io/2025/10/02/AI与技术/吴恩达面向开发者的大模型手册4使用LangChain访问个人数据/吴恩达面向开发者的大模型手册4使用LangChain访问个人数据/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Peng Yue</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/02/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C3%E4%BD%BF%E7%94%A8LangChain%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C3%E4%BD%BF%E7%94%A8LangChain%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" title="吴恩达面向开发者的大模型手册3使用LangChain开发应用程序">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">吴恩达面向开发者的大模型手册3使用LangChain开发应用程序</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/01/AI%E4%B8%8E%E6%8A%80%E6%9C%AF/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C1%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/%E5%90%B4%E6%81%A9%E8%BE%BE%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C1%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/" title="吴恩达面向开发者的大模型手册1面向开发者的提示工程">
                        <span class="hidden-mobile">吴恩达面向开发者的大模型手册1面向开发者的提示工程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>Peng Yue</span> <i class="iconfont icon-love"></i> <span>Product Manager</span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
